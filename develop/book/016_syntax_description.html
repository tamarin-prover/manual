<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamarin Prover Manual</title>
  <link rel="stylesheet" type="text/css" href="book.css">
  <script src="book.js"></script>
  <link rel="stylesheet" href="styles/github.css">
  <!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
  </head>

<body class="tamarindoc">
  <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
      <span class="sr-only">Toggle navigation</span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
    <ul class='chapter'>
      <!-- <li><a href='000_prelims.html'><b>0. </b>Preliminaries</a></li> -->
      <li><a href='001_introduction.html'><b>1. </b> Introduction</a></li>
      <li><a href='002_installation.html'><b>2. </b> Installation</a></li>
      <li><a href='003_example.html'><b>3. </b> First Example</a></li>
      <li><a href='004_cryptographic-messages.html'><b>4. </b> Cryptographic Messages</a></li>
      <li><a href='005_protocol-specification-rules.html'><b>5. </b> Protocol Specification using Rules</a></li>
      <li><a href='006_protocol-specification-processes.html'><b>6. </b> Protocol Specification using Processes</a></li>
      <li><a href='007_property-specification.html'><b>7. </b> Property Specification</a></li>
      <li><a href='008_accountability.html'><b>8. </b> Accountability</a></li>
      <li><a href='009_precomputation.html'><b>9. </b> Precomputation</a></li>
      <li><a href='010_modeling-issues.html'><b>10. </b> Modeling Issues</a></li>
      <li><a href='011_advanced-features.html'><b>11. </b> Advanced Features</a></li>
      <li><a href='012_case-studies.html'><b>12.</b> Case Studies</a></li>
      <li><a href='013_toolchains.html'><b>13.</b> Toolchains</a></li>
      <li><a href='014_limitations.html'><b>14.</b> Limitations</a></li>
      <li><a href='015_contact-and-further-reading.html'><b>15.</b> Contact Information and Further Reading</a></li>
      <li><a href='016_syntax_description.html'><b>16.</b> Syntax Description</a></li>
    </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
      <p class="halfbreak">
      </p>
      <h1 id="syntax-description">Syntax Description</h1>
      <p>Here, we explain the formal syntax of the security protocol
      theory format that is processed by Tamarin.</p>
      <p>Comments are C-style:</p>
      <pre><code>/* for a multi-line comment */
// for a line-comment</code></pre>
      <p>All security protocol theory are named and delimited by
      <code>begin</code> and <code>end</code>. We explain the
      non-terminals of the body in the following paragraphs.</p>
      <pre class="tamarin"><code>  theory  ::=  &#39;theory&#39; (ident: theory_name) (&#39;configuration&#39; &#39;:&#39; &#39;&quot;&#39; commandline &#39;&quot;&#39;)? &#39;begin&#39; _body_item* &#39;end&#39; /./*
  _body_item  ::=  preprocessor 
                   | _signature_spec 
                   | global_heuristic 
                   | tactic 
                   | process 
                   | let 
                   | export 
                   | _rule 
                   | restriction 
                   | case_test 
                   | _lemma 
                   | formal_comment</code></pre>
      <p>Here, we use the term signature more liberally to denote both
      the defined function symbols and the equalities describing their
      interaction. Note that our parser is stateful and remembers what
      functions have been defined. It will only parse function
      applications of defined functions.</p>
      <pre class="tamarin"><code>  _signature_spec  ::=  built_ins 
                            | functions 
                            | equations 
                            | predicates 
                            | macros 
                            | options
  _function_sym  ::=  function_untyped 
                            | function_typed
  equations  ::=  &gt;(&#39;equations&#39; (&#39;[&#39; &#39;convergent&#39; &#39;]&#39;)? &#39;:&#39; equation (&#39;,&#39; equation)* &#39;,&#39;?)
  equation  ::=  (_term: left) &#39;=&#39; (_term: right)</code></pre>
      <p>Note that the equations must be convergent and have the Finite
      Variant Property (FVP), and do not allow the use of fixed public
      names in the terms. Tamarin provides built-in sets of function
      definitions and equations. They are expanded upon parsing and you
      can therefore inspect them by pretty printing the file using
      <code>tamarin-prover your_file.spthy</code>. The built-in
      <code>diffie-hellman</code> is special. It refers to the equations
      given in Section <a
      href="004_cryptographic-messages.html#sec:equational-theories">Cryptographic
      Messages</a>. You need to enable it to parse terms containing
      exponentiations, e.g., g ^ x.</p>
      <pre class="tamarin"><code>  built_ins  ::=  &#39;builtins&#39; &#39;:&#39; built_in (&#39;,&#39; built_in)* &#39;,&#39;?
  built_in  ::=  &#39;diffie-hellman&#39; 
                  | &#39;hashing&#39; 
                  | &#39;symmetric-encryption&#39; 
                  | &#39;asymmetric-encryption&#39; 
                  | &#39;signing&#39; 
                  | &#39;bilinear-pairing&#39; 
                  | &#39;xor&#39; 
                  | &#39;multiset&#39; 
                  | &#39;natural-numbers&#39; 
                  | &#39;revealing-signing&#39; 
                  | &#39;locations-report&#39; 
                  | &#39;reliable-channel&#39; 
                  | &#39;dest-pairing&#39; 
                  | &#39;dest-signing&#39; 
                  | &#39;dest-symmetric-encryption&#39; 
                  | &#39;dest-asymmetric-encryption&#39;</code></pre>
      <p>A global heuristic sets the default heuristic that will be used
      when autoproving lemmas in the file. The specified goal ranking
      can be any of those discussed in Section <a
      href="010_advanced-features.html#sec:heuristics">Heuristics</a>.</p>
      <pre class="tamarin"><code>  global_heuristic  ::=  &#39;heuristic&#39; &#39;:&#39; (_goal_ranking+: goal_ranking)
  _goal_ranking  ::=  standard_goal_ranking 
                              | oracle_goal_ranking 
                              | tactic_goal_ranking
  standard_goal_ranking  ::=  /[CISPcisp][CISPcisp]?[CISPcisp]?[CISPcisp]?/
  oracle_goal_ranking  ::=  (&#39;O&#39; 
                              | &#39;o&#39;) (&#39;&quot;&#39; param &#39;&quot;&#39;)?
  tactic_goal_ranking  ::=  &#39;{&#39; ident &#39;}&#39;
  param  ::=  /[^&quot;]*/</code></pre>
      <p>The tactics allow the user to write their own heuristics based
      on the lemmas there are trying to prove. Their use is descibed in
      in Section <a
      href="010_advanced-features.html#sec:fact-annotations#subsec:tactic">Using
      a Tactic</a>.</p>
      <pre class="tamarin"><code>  standard_goal_ranking  ::=  /[CISPcisp][CISPcisp]?[CISPcisp]?[CISPcisp]?/
  tactic  ::=  &#39;tactic&#39; &#39;:&#39; ident presort? ((prio+ deprio*) 
                              | (prio* deprio+))
  presort  ::=  &#39;presort&#39; &#39;:&#39; standard_goal_ranking
  prio  ::=  &#39;prio&#39; &#39;:&#39; (&#39;{&#39; post_ranking &#39;}&#39;)? _function+
  deprio  ::=  &#39;deprio&#39; &#39;:&#39; (&#39;{&#39; post_ranking &#39;}&#39;)? _function+
  post_ranking  ::=  &#39;smallest&#39; 
                              | &#39;id&#39;
  _function  ::=  or_function 
                              | and_function 
                              | not_function 
                              | std_function
  and_function  ::=  &lt;LOGICAL_AND(_function &#39;&amp;&#39; _function)
  not_function  ::=  LOGICAL_NOT(&#39;not&#39; _function)
  function_name  ::=  &#39;regex&#39; 
                              | &#39;isFactName&#39; 
                              | &#39;isInFactTerms&#39; 
                              | &#39;dhreNoise&#39; 
                              | &#39;defaultNoise&#39; 
                              | &#39;reasonableNoncesNoise&#39; 
                              | &#39;nonAbsurdGoal&#39;</code></pre>
      <p>Multiset rewriting rules are specified as follows. The protocol
      corresponding to a security protocol theory is the set of all
      multiset rewriting rules specified in the body of the theory. Rule
      variants can be explicitly given, as well as the left and right
      instances of a rule in diff-mode. (When called with
      <code>--diff</code>, Tamarin will parse <code>diff_rule</code>
      instead of <code>rule</code>).</p>
      <pre class="tamarin"><code>  _rule  ::=  rule 
                               | diff_rule
  rule  ::=  simple_rule variants?
  diff_rule  ::=  simple_rule &#39;left&#39; (rule: left) &#39;right&#39; (rule: right)
  simple_rule  ::=  &#39;rule&#39; modulo? (ident: rule_identifier) rule_attrs? &#39;:&#39; rule_let_block? premise (&#39;--&gt;&#39; 
                               | action_fact) conclusion
  variants  ::=  &#39;variants&#39; simple_rule (&#39;,&#39; simple_rule)*
  modulo  ::=  &#39;(&#39; &#39;modulo&#39; (&#39;E&#39; 
                               | &#39;AC&#39;) &#39;)&#39;
  rule_attrs  ::=  &#39;[&#39; rule_attr (&#39;,&#39; rule_attr)* &#39;,&#39;? &#39;]&#39;
  rule_attr  ::=  rule_attr_color 
                               | &#39;no_derivcheck&#39; 
                               | &#39;issapicrule&#39; 
                               | rule_process 
                               | rule_role
  rule_let_block  ::=  &#39;let&#39; rule_let_term+ &#39;in&#39;
  rule_let_term  ::=  ((msg_var_or_nullary_fun 
                               | nat_var): left) &#39;=&#39; (_term: right)
  msg_var_or_nullary_fun  ::=  VARIABLE((ident: variable_identifier) (&#39;.&#39; natural)? (&#39;:&#39; &#39;msg&#39;)?)
  hexcolor  ::=  (&#39;&#39;&#39; @(&#39;#&#39;)? @(/[0-9a-fA-F]{1,6}/) &#39;&#39;&#39;) 
                               | (@(&#39;#&#39;)? @(/[0-9a-fA-F]{1,6}/))</code></pre>
      <p>Rule annotations do not influence the rule’s semantics. A color
      is represented as a triplet of 8 bit hexadecimal values optionally
      preceded by ‘#’, and is used as the background color of the rule
      when it is rendered in graphs.</p>
      <p>The let-block allows more succinct specifications. The
      equations are applied in a bottom-up fashion. For example,</p>
      <pre><code>let x = y
    y = &lt;z,x&gt;
in [] --&gt; [ A(y)]    is desugared to    [] --&gt; [ A(&lt;z,y&gt;) ]</code></pre>
      <p>This becomes a lot less confusing if you keep the set of
      variables on the left-hand side separate from the free variables
      on the right-hand side.</p>
      <p>Macros works similarly to let-blocks, but apply globally to all
      rules.</p>
      <pre class="tamarin"><code>  macros  ::=  &#39;macros&#39; &#39;:&#39; macro (&#39;,&#39; macro)*
  macro  ::=  (ident: macro_identifier) &#39;(&#39; (_non_temporal_var (&#39;,&#39; _non_temporal_var)*)? &#39;)&#39; &#39;=&#39; (_term: term)
  _non_temporal_var  ::=  pub_var 
                          | fresh_var 
                          | msg_var_or_nullary_fun 
                          | nat_var</code></pre>
      <p>Configuration blocks allow the specification of certain Tamarin
      command line options in the model file itself. Options passed over
      the command line override options given in a configuration
      block.</p>
      <pre><code>configuration := &#39;configuration&#39; &#39;:&#39; &#39;&quot;&#39; option (&#39; &#39; option)* &#39;&quot;&#39;
option          := &#39;--auto-sources&#39; | (&#39;--stop-on-trace&#39; &#39;=&#39; search_method)
search_method := &#39;DFS&#39; | &#39;BFS&#39; | &#39;SEQDFS&#39; | &#39;NONE&#39;</code></pre>
      <p>Restrictions specify restrictions on the set of traces
      considered, i.e., they filter the set of traces of a protocol. The
      formula of a restriction is available as an assumption in the
      proofs of <em>all</em> security properties specified in this
      security protocol theory. In observational equivalence mode,
      restrictions can be associated to one side.</p>
      <pre class="tamarin"><code>  restriction  ::=  (&#39;restriction&#39; 
                         | &#39;axiom&#39;) (ident: restriction_identifier) restriction_attr? &#39;:&#39; &#39;&quot;&#39; (_formula: formula) &#39;&quot;&#39;
  restriction_attr  ::=  &#39;[&#39; (&#39;left&#39; 
                         | &#39;right&#39;) &#39;]&#39;</code></pre>
      <p>Lemmas specify security properties. By default, the given
      formula is interpreted as a property that must hold for all traces
      of the protocol of the security protocol theory. You can change
      this using the ‘exists-trace’ trace quantifier. When exporting,
      one may indicate which lemmas should only be included in certain
      output formats.</p>
      <pre class="tamarin"><code>  _lemma  ::=  lemma 
                         | diff_lemma 
                         | accountability_lemma 
                         | equiv_lemma 
                         | diff_equiv_lemma
  lemma  ::=  &#39;lemma&#39; modulo? (ident: lemma_identifier) diff_lemma_attrs? &#39;:&#39; trace_quantifier? &#39;&quot;&#39; (_formula: formula) &#39;&quot;&#39; (_proof_skeleton: proof_skeleton)?
  lemma_attr  ::=  &#39;sources&#39; 
                         | &#39;reuse&#39; 
                         | &#39;use_induction&#39; 
                         | (&#39;output=&#39; &#39;[&#39; language (&#39;,&#39; language)* &#39;]&#39;) 
                         | (&#39;hide_lemma=&#39; ident) 
                         | (&#39;heuristic=&#39; (_goal_ranking+: goal_ranking))
  trace_quantifier  ::=  &#39;all-traces&#39; 
                         | &#39;exists-trace&#39;</code></pre>
      <p>In observational equivalence mode, lemmas can be associated to
      one side.</p>
      <pre class="tamarin"><code>  diff_lemma  ::=  &#39;diffLemma&#39; modulo? (ident: lemma_identifier) diff_lemma_attrs? &#39;:&#39; (_proof_skeleton: proof_skeleton)?
  diff_lemma_attrs  ::=  &#39;[&#39; (diff_lemma_attr 
                         | lemma_attr) (&#39;,&#39; (diff_lemma_attr 
                         | lemma_attr))* &#39;,&#39;? &#39;]&#39;
  diff_lemma_attr  ::=  &#39;left&#39; 
                         | &#39;right&#39;</code></pre>
      <p>A proof skeleton is a complete or partial proof as output by
      the Tamarin prover. It indicates the proof method used at each
      step, which may include multiple cases.</p>
      <pre class="tamarin"><code>  _proof_skeleton  ::=  solved 
                               | mirrored 
                               | by_method 
                               | method_skeleton 
                               | cases
  solved  ::=  &#39;SOLVED&#39;
  mirrored  ::=  &#39;MIRRORED&#39;
  by_method  ::=  &#39;by&#39; _proof_methods
  method_skeleton  ::=  _proof_methods (_proof_skeleton: proof_skeleton)
  cases  ::=  case (&#39;next&#39; case)* &#39;qed&#39;
  _proof_methods  ::=  &gt;(proof_method 
                               | step+)
  proof_method  ::=  &#39;sorry&#39; 
                               | &#39;simplify&#39; 
                               | (&#39;solve&#39; &#39;(&#39; goal &#39;)&#39;) 
                               | &#39;contradiction&#39; 
                               | &#39;induction&#39; 
                               | &#39;rule-equivalence&#39; 
                               | &#39;backward-search&#39; 
                               | &#39;ATTACK&#39;
  goal  ::=  premise_goal 
                               | action_goal 
                               | chain_goal 
                               | disjunction_split_goal 
                               | eq_split_goal
  premise_goal  ::=  _fact &#39;▶&#39; natural_subscript temporal_var
  premise_goal  ::=  _fact &#39;▶&#39; natural_subscript temporal_var
  action_goal  ::=  _fact &#39;@&#39; temporal_var
  chain_goal  ::=  &#39;(&#39; temporal_var &#39;,&#39; natural &#39;)&#39; &#39;~~&gt;&#39; &#39;(&#39; temporal_var &#39;,&#39; natural &#39;)&#39;
  disjunction_split_goal  ::=  CHAIN_GOAL((_formula: formula) ((&#39;||&#39; 
                               | &#39;∥&#39;) (_formula: formula))+)
  eq_split_goal  ::=  &#39;splitEqs&#39; &#39;(&#39; natural &#39;)&#39;
  natural  ::=  /[0-9]+/
  natural_subscript  ::=  (&#39;₀&#39; 
                               | &#39;₁&#39; 
                               | &#39;₂&#39; 
                               | &#39;₃&#39; 
                               | &#39;₄&#39; 
                               | &#39;₅&#39; 
                               | &#39;₆&#39; 
                               | &#39;₇&#39; 
                               | &#39;₈&#39; 
                               | &#39;₉&#39;)+</code></pre>
      <p>Formal comments are used to make the input more readable. In
      contrast to <code>/*...*/</code> and <code>//...</code> comments,
      formal comments are stored and output again when pretty-printing a
      security protocol theory.</p>
      <pre class="tamarin"><code>  formal_comment  ::=  (ident: comment_identifier) @(&#39;{*&#39; /[^*]*\*+([^}*][^*]*\*+)*/ &#39;}&#39;)</code></pre>
      <p>For the syntax of terms, you best look at our examples. A
      common pitfall is to use an undefined function symbol. This
      results in an error message pointing to a position slightly before
      the actual use of the function due to some ambiguity in the
      grammar.</p>
      <p>We provide special syntax for tuples, multisets, xors,
      multiplications, exponentiation, nullary and binary function
      symbols. An n-ary tuple <code>&lt;t1,...,tn&gt;</code> is parsed
      as n-ary, right-associative application of pairing. Multiplication
      and exponentiation are parsed left-associatively. For a binary
      operator <code>enc</code> you can write <code>enc{m}k</code> or
      <code>enc(m,k)</code>. For nullary function symbols, there is no
      need to write <code>nullary()</code>. Note that the number of
      arguments of an n-ary function application must agree with the
      arity given in the function definition.</p>
      <pre class="tamarin"><code>  _term  ::=  tuple_term 
                  | mset_term 
                  | nested_term 
                  | nullary_fun 
                  | binary_app 
                  | nary_app 
                  | _literal
  mset_term  ::=  &lt;MUL_SET((nat_term: left) (&#39;++&#39; 
                  | &#39;+&#39;) (nat_term: right))
  nat_term  ::=  &lt;ADD((xor_term: left) &#39;%+&#39; (xor_term: right))
  xor_term  ::=  &lt;EXCLUSIVE_OR((mult_term: left) (&#39;XOR&#39; 
                  | &#39;⊕&#39;) (mult_term: right))
  mult_term  ::=  &lt;MULTIPLY((exp_term: left) &#39;*&#39; (exp_term: right))
  exp_term  ::=  &gt;EXPONENTIAL((_term: base) &#39;^&#39; (_term: exponent))</code></pre>
      <p>Tamarin’s parser checks that functions were previously defined
      and are used with the correct arity.</p>
      <pre><code>    nullary_fun := &lt;all-nullary-functions-defined-up-to-here&gt;
    binary_app  := binary_fun &#39;{&#39; tupleterm &#39;}&#39; term
    binary_fun  := &lt;all-binary-functions-defined-up-to-here&gt;
    nary_app    := nary_fun &#39;(&#39; multterm* &#39;)&#39;</code></pre>
      <p>External tools may instead use the following grammar and check
      these conditions after parsing.</p>
      <pre class="tamarin"><code>  binary_app  ::=  FUNCTION((ident: function_identifier) &#39;{&#39; (_term: argument) (&#39;,&#39; (_term: argument))*? &#39;}&#39; (_term: argument))
  nary_app  ::=  FUNCTION((ident: function_identifier) &#39;(&#39; arguments &#39;)&#39;)</code></pre>
      <p>Literals and variables appear in many forms.</p>
      <pre class="tamarin"><code>  _literal  ::=  pub_name 
                          | fresh_name 
                          | _non_temporal_var 
                          | comp_var 
                          | _custom_type_var
  _non_temporal_var  ::=  pub_var 
                          | fresh_var 
                          | msg_var_or_nullary_fun 
                          | nat_var</code></pre>
      <p>When appearing in formulas or rules, they have an identifier
      and a sort.</p>
      <pre class="tamarin"><code>  _non_temporal_var  ::=  pub_var 
                               | fresh_var 
                               | msg_var_or_nullary_fun 
                               | nat_var
  pub_var  ::=  VARIABLE((&#39;$&#39; (ident: variable_identifier) (&#39;.&#39; natural)?) 
                               | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;pub&#39;))
  fresh_var  ::=  VARIABLE((&#39;~&#39; (ident: variable_identifier) (&#39;.&#39; natural)?) 
                               | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;fresh&#39;))
  msg_var_or_nullary_fun  ::=  VARIABLE((ident: variable_identifier) (&#39;.&#39; natural)? (&#39;:&#39; &#39;msg&#39;)?)
  nat_var  ::=  (&#39;%&#39; (ident: variable_identifier) (&#39;.&#39; natural)? (&#39;:&#39; &#39;nat&#39;)?) 
                               | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;nat&#39;)
  fresh_name  ::=  &#39;~&#39;&#39; /[^\n&#39;]+/ &#39;&#39;&#39;</code></pre>
      <p>SAPIC processes also have (optional) types. Moreover, literals
      in pattern can signify with a <code>=</code> if they are matched
      or bound.</p>
      <pre class="tamarin"><code>  comp_var  ::=  &#39;=&#39; _literal
  _custom_type_var  ::=  custom_var 
                         | any_var
  custom_var  ::=  -1(_literal &#39;:&#39; (ident: variable_type))</code></pre>
      <p>Facts do not have to be defined up-front. This will probably
      change once we implement user-defined sorts. Facts prefixed with
      <code>!</code> are persistent facts. All other facts are linear.
      There are six reserved fact symbols: In, Out, KU, KD, Fr, and K.
      KU and KD facts are used for construction and deconstruction
      rules. KU-facts also log the messages deduced by construction
      rules. Note that KU-facts have arity 2. Their first argument is
      used to track the exponentiation tags. See the
      <code>loops/Crypto_API_Simple.spthy</code> example for more
      information.</p>
      <pre class="tamarin"><code>  _facts  ::=  &lt;(_fact (&#39;,&#39; _fact)*)
  _fact  ::=  (fact -&gt; linear_fact) 
                     | (&#39;!&#39; (fact -&gt; persistent_fact))
  fact_annotes  ::=  &#39;[&#39; fact_annote (&#39;,&#39; fact_annote)* &#39;]&#39;
  fact_annote  ::=  &#39;+&#39; 
                     | &#39;-&#39; 
                     | &#39;no_precomp&#39;</code></pre>
      <pre><code>facts := fact (&#39;,&#39; fact)*
fact  := [&#39;!&#39;] ident &#39;(&#39; [msetterm (&#39;,&#39; msetterm)*] &#39;)&#39; [fact_annotes]
fact_annotes := &#39;[&#39; fact_annote (&#39;,&#39; fact_annote)* &#39;]&#39;
fact_annote  := &#39;+&#39; | &#39;-&#39; | &#39;no_precomp&#39;</code></pre>
      <p>Fact annotations can be used to adjust the priority of
      corresponding goals in the heuristics, or influence the
      precomputation step performed by Tamarin, as described in Section
      <a href="010_advanced-features.html#sec:fact-annotations">Advanced
      Features</a>.</p>
      <p>Formulas are trace formulas as described previously. Note that
      we are a bit more liberal with respect to guardedness. We accept a
      conjunction of atoms as guards.</p>
      <pre><code>formula     := imp [(&#39;&lt;=&gt;&#39; | &#39;⇔&#39;) imp]
imp         := disjunction [(&#39;==&gt;&#39; | &#39;⇒&#39;) imp]
disjunction := conjunction ((&#39;|&#39; | &#39;∨&#39;) conjunction)* // left-associative
conjunction := negation ((&#39;&amp;&#39; | &#39;∧&#39;) negation)*       // left-associative
negation    := [&#39;not&#39; | &#39;¬&#39;] atom
atom        := &#39;⊥&#39; | &#39;F&#39; | &#39;⊤&#39; | &#39;T&#39;           // true or false
             | &#39;(&#39; formula &#39;)&#39;                 // nested formula
             | &#39;last&#39; &#39;(&#39; node_var &#39;)&#39;         // &#39;last&#39; temporal variable for induction
             | fact &#39;@&#39; node_var               // action
             | node_var &#39;&lt;&#39; node_var           // ordering of temporal variables
             | msetterm &#39;=&#39; msetterm           // equality of terms
             | msetterm (&#39;&lt;&lt;&#39; | &#39;⊏&#39;) msetterm  // subterm relation
             | node_var &#39;=&#39; node_var           // equality of temporal variables
             | (&#39;Ex&#39; | &#39;∃&#39; | &#39;All&#39; | &#39;∀&#39;)      // quantified formula
                    lvar+ &#39;.&#39; formula

lvar        := node_var | nonnode_var</code></pre>
      <p>Identifiers always start with a letter or number, and may
      contain underscores after the first character. Moreover, they must
      not be one of the reserved keywords <code>let</code>,
      <code>in</code>, or <code>rule</code>. Although identifiers
      beginning with a number are valid, they are not allowed as the
      names of facts (which must begin with an upper-case letter).</p>
      <h2 id="full-syntax">Full syntax</h2>
      <p>The following <a
      href="https://tree-sitter.github.io/tree-sitter/">Treesitter</a>-generated
      eBNF is regularly tested against the files in
      <code>examples</code>. It includes the aforementioned rules, and
      those concerning the <a
      href="006_protocol-specification-processes.html">process calculus
      SAPIC+</a>.</p>
      <pre class="tamarin"><code>extras  ::=  { multi_comment single_comment /\s|\\\r?\n|\u00A0/ }

conflicts  ::=  { { pub_var } { fresh_var } { msg_var_or_nullary_fun } { temporal_var } { nat_var } { pub_var fresh_var msg_var_or_nullary_fun temporal_var nat_var } { pub_var fresh_var msg_var_or_nullary_fun nat_var } { accountability_lemma diff_lemma } { lemma diff_lemma } { nary_app predicate_ref } { nullary_fun nary_app msg_var_or_nullary_fun } }

externals  ::=  { multi_comment single_comment }

precedences  ::=  { { &#39;NESTED&#39; &#39;FUNCTION&#39; &#39;VARIABLE&#39; &#39;EXPONENTIAL&#39; &#39;MULTIPLY&#39; &#39;ADD&#39; &#39;MUL_SET&#39; &#39;TUPLE&#39; &#39;NULLARY_FUN&#39; &#39;ATOM&#39; &#39;LOGICAL_NOT&#39; &#39;EXCLUSIVE_OR&#39; &#39;LOGICAL_AND&#39; &#39;LOGICAL_OR&#39; &#39;LOGICAL_IMPLICATION&#39; &#39;LOGICAL_IFF&#39; &#39;CHAIN_GOAL&#39; } { &#39;NON_DIFF&#39; &#39;DIFF&#39; } { &#39;REPLICATION&#39; &#39;EVENT&#39; &#39;CHOICE&#39; &#39;PROCESS_LET&#39; &#39;LOOKUP&#39; &#39;CONDITIONAL&#39; } }

word  ::=  ident

rules:
  theory  ::=  &#39;theory&#39; (ident: theory_name) (&#39;configuration&#39; &#39;:&#39; &#39;&quot;&#39; commandline &#39;&quot;&#39;)? &#39;begin&#39; _body_item* &#39;end&#39; /./*
  commandline  ::=  (&#39;--auto-sources&#39; | (&#39;--stop-on-trace&#39; &#39;=&#39; _search_strategy))+
  _search_strategy  ::=  &#39;BFS&#39; | &#39;DFS&#39; | &#39;SEQDFS&#39; | &#39;bfs&#39; | &#39;dfs&#39; | &#39;seqdfs&#39;
  _body_item  ::=  preprocessor | _signature_spec | global_heuristic | tactic | process | let | export | _rule | restriction | case_test | _lemma | formal_comment
  preprocessor  ::=  ifdef | define | include
  ifdef  ::=  &#39;#ifdef&#39; _ifdef_formula _body_item* (&#39;#else&#39; _body_item*)? &#39;#endif&#39;
  define  ::=  &#39;#define&#39; ident
  include  ::=  &#39;#include&#39; &#39;&quot;&#39; (param -&gt; path) &#39;&quot;&#39;
  _ifdef_formula  ::=  ifdef_nested | ifdef_or | ifdef_and | ifdef_not | ident
  ifdef_nested  ::=  NESTED(&#39;(&#39; _ifdef_formula &#39;)&#39;)
  ifdef_or  ::=  &lt;LOGICAL_OR(_ifdef_formula &#39;|&#39; _ifdef_formula)
  ifdef_and  ::=  &lt;LOGICAL_AND(_ifdef_formula &#39;&amp;&#39; _ifdef_formula)
  ifdef_not  ::=  LOGICAL_NOT(&#39;not&#39; _ifdef_formula)
  _signature_spec  ::=  built_ins | functions | equations | predicates | macros | options
  built_ins  ::=  &#39;builtins&#39; &#39;:&#39; built_in (&#39;,&#39; built_in)* &#39;,&#39;?
  built_in  ::=  &#39;diffie-hellman&#39; | &#39;hashing&#39; | &#39;symmetric-encryption&#39; | &#39;asymmetric-encryption&#39; | &#39;signing&#39; | &#39;bilinear-pairing&#39; | &#39;xor&#39; | &#39;multiset&#39; | &#39;natural-numbers&#39; | &#39;revealing-signing&#39; | &#39;locations-report&#39; | &#39;reliable-channel&#39; | &#39;dest-pairing&#39; | &#39;dest-signing&#39; | &#39;dest-symmetric-encryption&#39; | &#39;dest-asymmetric-encryption&#39;
  functions  ::=  &gt;(&#39;functions&#39; &#39;:&#39; _function_sym (&#39;,&#39; _function_sym)* &#39;,&#39;?)
  _function_sym  ::=  function_untyped | function_typed
  function_untyped  ::=  (ident: function_identifier) &#39;/&#39; (natural: arity) (&#39;[&#39; function_attribute (&#39;,&#39; function_attribute)* &#39;,&#39;? &#39;]&#39;)?
  function_attribute  ::=  &#39;private&#39; | &#39;destructor&#39;
  function_typed  ::=  (ident: function_identifier) &#39;(&#39; arguments? &#39;)&#39; &#39;:&#39; (ident: function_type)
  equations  ::=  &gt;(&#39;equations&#39; (&#39;[&#39; &#39;convergent&#39; &#39;]&#39;)? &#39;:&#39; equation (&#39;,&#39; equation)* &#39;,&#39;?)
  equation  ::=  (_term: left) &#39;=&#39; (_term: right)
  predicates  ::=  (&#39;predicate&#39; | &#39;predicates&#39;) &#39;:&#39; predicate (&#39;,&#39; predicate)*
  predicate  ::=  (predicate_def -&gt; &#39;&#39;) &#39;&lt;=&gt;&#39; (_formula: formula)
  predicate_def  ::=  (ident: predicate_identifier) &#39;(&#39; arguments? &#39;)&#39;
  options  ::=  &#39;options&#39; &#39;:&#39; option (&#39;,&#39; option)* &#39;,&#39;?
  option  ::=  &#39;translation-state-optimisation&#39; | &#39;translation-progress&#39; | &#39;translation-asynchronous-channels&#39; | &#39;translation-compress-events&#39; | &#39;translation-allow-pattern-lookups&#39;
  global_heuristic  ::=  &#39;heuristic&#39; &#39;:&#39; (_goal_ranking+: goal_ranking)
  _goal_ranking  ::=  standard_goal_ranking | oracle_goal_ranking | tactic_goal_ranking
  standard_goal_ranking  ::=  /[CISPcisp][CISPcisp]?[CISPcisp]?[CISPcisp]?/
  oracle_goal_ranking  ::=  (&#39;O&#39; | &#39;o&#39;) (&#39;&quot;&#39; param &#39;&quot;&#39;)?
  tactic_goal_ranking  ::=  &#39;{&#39; ident &#39;}&#39;
  tactic  ::=  &#39;tactic&#39; &#39;:&#39; ident presort? ((prio+ deprio*) | (prio* deprio+))
  presort  ::=  &#39;presort&#39; &#39;:&#39; standard_goal_ranking
  prio  ::=  &#39;prio&#39; &#39;:&#39; (&#39;{&#39; post_ranking &#39;}&#39;)? _function+
  deprio  ::=  &#39;deprio&#39; &#39;:&#39; (&#39;{&#39; post_ranking &#39;}&#39;)? _function+
  post_ranking  ::=  &#39;smallest&#39; | &#39;id&#39;
  _function  ::=  or_function | and_function | not_function | std_function
  or_function  ::=  &lt;LOGICAL_OR(_function &#39;|&#39; _function)
  and_function  ::=  &lt;LOGICAL_AND(_function &#39;&amp;&#39; _function)
  not_function  ::=  LOGICAL_NOT(&#39;not&#39; _function)
  std_function  ::=  function_name (&#39;&quot;&#39; param &#39;&quot;&#39;)*
  function_name  ::=  &#39;regex&#39; | &#39;isFactName&#39; | &#39;isInFactTerms&#39; | &#39;dhreNoise&#39; | &#39;defaultNoise&#39; | &#39;reasonableNoncesNoise&#39; | &#39;nonAbsurdGoal&#39;
  process  ::=  &#39;process&#39; &#39;:&#39; _process
  _process  ::=  _elementary_process | _extended_process | _stateful_process | inline_msr_process | _nested_process | location_process | predefined_process
  _elementary_process  ::=  binding | output | input | conditional | process_let | deterministic_choice | non_deterministic_choice | null
  _extended_process  ::=  event | replication
  _stateful_process  ::=  set_state | delete_state | read_state | set_lock | remove_lock
  location_process  ::=  &#39;(&#39; _process &#39;)&#39; &#39;@&#39; ((_literal | tuple_term): location_identifier)
  inline_msr_process  ::=  &gt;(premise (&#39;--&gt;&#39; | action_fact) conclusion (&#39;;&#39; _process)?)
  _nested_process  ::=  &#39;(&#39; _process &#39;)&#39;
  predefined_process  ::=  &lt;-1(_term)
  binding  ::=  &gt;(&#39;new&#39; _literal (&#39;;&#39; _process)?)
  output  ::=  &gt;((&#39;out&#39; &#39;(&#39; _term &#39;,&#39; _term &#39;)&#39; (&#39;;&#39; _process)?) | (&#39;out&#39; &#39;(&#39; _term &#39;)&#39; (&#39;;&#39; _process)?))
  input  ::=  &gt;((&#39;in&#39; &#39;(&#39; _term &#39;,&#39; _term &#39;)&#39; (&#39;;&#39; _process)?) | (&#39;in&#39; &#39;(&#39; _term &#39;)&#39; (&#39;;&#39; _process)?))
  conditional  ::=  &gt;CONDITIONAL(&#39;if&#39; (_condition: condition) &#39;then&#39; (_process: then) (&#39;else&#39; (_process: else))?)
  process_let  ::=  &gt;PROCESS_LET(&#39;let&#39; term_eq+ &#39;in&#39; (_process: in) (&#39;else&#39; (_process: else))?)
  deterministic_choice  ::=  &lt;CHOICE(_process (&#39;|&#39; | &#39;||&#39;) _process)
  non_deterministic_choice  ::=  &lt;CHOICE(_process (&#39;+&#39;) _process)
  null  ::=  &#39;0&#39;
  event  ::=  &gt;EVENT(&#39;event&#39; _fact (&#39;;&#39; _process)?)
  replication  ::=  &gt;REPLICATION(&#39;!&#39; _process (&#39;;&#39; _process)?)
  set_state  ::=  &gt;(&#39;insert&#39; (_term: from) &#39;,&#39; (_term: to) (&#39;;&#39; _process)?)
  delete_state  ::=  &gt;(&#39;delete&#39; _term (&#39;;&#39; _process)?)
  read_state  ::=  &gt;LOOKUP(&#39;lookup&#39; (_term: from) &#39;as&#39; (_lvar: to) &#39;in&#39; (_process: in) (&#39;else&#39; (_process: else))? (&#39;;&#39; _process)?)
  set_lock  ::=  &gt;(&#39;lock&#39; _term (&#39;;&#39; _process)?)
  remove_lock  ::=  &gt;(&#39;unlock&#39; _term (&#39;;&#39; _process)?)
  _condition  ::=  equality_check | lesser_check | predicate_ref
  equality_check  ::=  (_term | _formula) @(1(&#39;=&#39;)) (_term | _formula)
  lesser_check  ::=  _term (&#39;(&lt;)&#39; | &#39;&lt;&lt;&#39;) _term
  let  ::=  &#39;let&#39; (_term: let_identifier) &#39;=&#39; _process
  export  ::=  &#39;export&#39; (ident: export_identifier) &#39;:&#39; &#39;&quot;&#39; export_query &#39;&quot;&#39;
  _rule  ::=  rule | diff_rule
  rule  ::=  simple_rule variants?
  diff_rule  ::=  simple_rule &#39;left&#39; (rule: left) &#39;right&#39; (rule: right)
  simple_rule  ::=  &#39;rule&#39; modulo? (ident: rule_identifier) rule_attrs? &#39;:&#39; rule_let_block? premise (&#39;--&gt;&#39; | action_fact) conclusion
  premise  ::=  &#39;[&#39; _facts? &#39;]&#39;
  action_fact  ::=  &#39;--[&#39; _facts_restrictions? &#39;]-&gt;&#39;
  conclusion  ::=  &#39;[&#39; _facts? &#39;]&#39;
  variants  ::=  &#39;variants&#39; simple_rule (&#39;,&#39; simple_rule)*
  modulo  ::=  &#39;(&#39; &#39;modulo&#39; (&#39;E&#39; | &#39;AC&#39;) &#39;)&#39;
  rule_attrs  ::=  &#39;[&#39; rule_attr (&#39;,&#39; rule_attr)* &#39;,&#39;? &#39;]&#39;
  rule_attr  ::=  rule_attr_color | &#39;no_derivcheck&#39; | &#39;issapicrule&#39; | rule_process | rule_role
  rule_attr_color  ::=  (&#39;color=&#39; | &#39;colour=&#39;) hexcolor
  rule_role  ::=  &#39;role&#39; &#39;=&#39; &#39;&quot;&#39; (ident: role_identifier) &#39;&quot;&#39;
  rule_process  ::=  &#39;process&#39; &#39;=&#39; &#39;&quot;&#39; ident &#39;&quot;&#39;
  rule_let_block  ::=  &#39;let&#39; rule_let_term+ &#39;in&#39;
  rule_let_term  ::=  ((msg_var_or_nullary_fun | nat_var): left) &#39;=&#39; (_term: right)
  macros  ::=  &#39;macros&#39; &#39;:&#39; macro (&#39;,&#39; macro)*
  macro  ::=  (ident: macro_identifier) &#39;(&#39; (_non_temporal_var (&#39;,&#39; _non_temporal_var)*)? &#39;)&#39; &#39;=&#39; (_term: term)
  embedded_restriction  ::=  &#39;_restrict&#39; &#39;(&#39; (_formula: formula) &#39;)&#39;
  _facts_restrictions  ::=  &lt;((_fact | embedded_restriction) (&#39;,&#39; (_fact | embedded_restriction))*)
  _facts  ::=  &lt;(_fact (&#39;,&#39; _fact)*)
  _fact  ::=  (fact -&gt; linear_fact) | (&#39;!&#39; (fact -&gt; persistent_fact))
  fact  ::=  &lt;((ident: fact_identifier) &#39;(&#39; arguments? &#39;)&#39; fact_annotes?)
  fact_annotes  ::=  &#39;[&#39; fact_annote (&#39;,&#39; fact_annote)* &#39;]&#39;
  fact_annote  ::=  &#39;+&#39; | &#39;-&#39; | &#39;no_precomp&#39;
  restriction  ::=  (&#39;restriction&#39; | &#39;axiom&#39;) (ident: restriction_identifier) restriction_attr? &#39;:&#39; &#39;&quot;&#39; (_formula: formula) &#39;&quot;&#39;
  restriction_attr  ::=  &#39;[&#39; (&#39;left&#39; | &#39;right&#39;) &#39;]&#39;
  case_test  ::=  &#39;test&#39; (ident: test_identifier) &#39;:&#39; &#39;&quot;&#39; (_formula: formula) &#39;&quot;&#39;
  _lemma  ::=  lemma | diff_lemma | accountability_lemma | equiv_lemma | diff_equiv_lemma
  lemma  ::=  &#39;lemma&#39; modulo? (ident: lemma_identifier) diff_lemma_attrs? &#39;:&#39; trace_quantifier? &#39;&quot;&#39; (_formula: formula) &#39;&quot;&#39; (_proof_skeleton: proof_skeleton)?
  lemma_attr  ::=  &#39;sources&#39; | &#39;reuse&#39; | &#39;use_induction&#39; | (&#39;output=&#39; &#39;[&#39; language (&#39;,&#39; language)* &#39;]&#39;) | (&#39;hide_lemma=&#39; ident) | (&#39;heuristic=&#39; (_goal_ranking+: goal_ranking))
  language  ::=  &#39;spthy&#39; | &#39;spthytyped&#39; | &#39;msr&#39; | &#39;proverif&#39; | &#39;deepsec&#39;
  diff_lemma  ::=  &#39;diffLemma&#39; modulo? (ident: lemma_identifier) diff_lemma_attrs? &#39;:&#39; (_proof_skeleton: proof_skeleton)?
  diff_lemma_attrs  ::=  &#39;[&#39; (diff_lemma_attr | lemma_attr) (&#39;,&#39; (diff_lemma_attr | lemma_attr))* &#39;,&#39;? &#39;]&#39;
  diff_lemma_attr  ::=  &#39;left&#39; | &#39;right&#39;
  accountability_lemma  ::=  &#39;lemma&#39; (ident: lemma_identifier) &#39;:&#39; (ident: test_identifier) (&#39;,&#39; (ident: test_identifier))* (&#39;account&#39; | &#39;accounts&#39;) &#39;for&#39; &#39;&quot;&#39; (_formula: formula) &#39;&quot;&#39;
  equiv_lemma  ::=  &#39;equivLemma&#39; &#39;:&#39; (_process: first) (_process: second)
  diff_equiv_lemma  ::=  &#39;diffEquivLemma&#39; &#39;:&#39; _process
  trace_quantifier  ::=  &#39;all-traces&#39; | &#39;exists-trace&#39;
  _proof_skeleton  ::=  solved | mirrored | by_method | method_skeleton | cases
  solved  ::=  &#39;SOLVED&#39;
  mirrored  ::=  &#39;MIRRORED&#39;
  by_method  ::=  &#39;by&#39; _proof_methods
  method_skeleton  ::=  _proof_methods (_proof_skeleton: proof_skeleton)
  cases  ::=  case (&#39;next&#39; case)* &#39;qed&#39;
  case  ::=  &#39;case&#39; (ident: case_identifier) (_proof_skeleton: proof_skeleton)
  _proof_methods  ::=  &gt;(proof_method | step+)
  proof_method  ::=  &#39;sorry&#39; | &#39;simplify&#39; | (&#39;solve&#39; &#39;(&#39; goal &#39;)&#39;) | &#39;contradiction&#39; | &#39;induction&#39; | &#39;rule-equivalence&#39; | &#39;backward-search&#39; | &#39;ATTACK&#39;
  step  ::=  &#39;step&#39; &#39;(&#39; proof_method &#39;)&#39;
  goal  ::=  premise_goal | action_goal | chain_goal | disjunction_split_goal | eq_split_goal
  premise_goal  ::=  _fact &#39;▶&#39; natural_subscript temporal_var
  action_goal  ::=  _fact &#39;@&#39; temporal_var
  chain_goal  ::=  &#39;(&#39; temporal_var &#39;,&#39; natural &#39;)&#39; &#39;~~&gt;&#39; &#39;(&#39; temporal_var &#39;,&#39; natural &#39;)&#39;
  disjunction_split_goal  ::=  CHAIN_GOAL((_formula: formula) ((&#39;||&#39; | &#39;∥&#39;) (_formula: formula))+)
  eq_split_goal  ::=  &#39;splitEqs&#39; &#39;(&#39; natural &#39;)&#39;
  _term  ::=  tuple_term | mset_term | nested_term | nullary_fun | binary_app | nary_app | _literal
  tuple_term  ::=  TUPLE(&#39;&lt;&#39; ((mset_term): term) (&#39;,&#39; (mset_term: term))* &#39;&gt;&#39;)
  mset_term  ::=  &lt;MUL_SET((nat_term: left) (&#39;++&#39; | &#39;+&#39;) (nat_term: right))
  nat_term  ::=  &lt;ADD((xor_term: left) &#39;%+&#39; (xor_term: right))
  xor_term  ::=  &lt;EXCLUSIVE_OR((mult_term: left) (&#39;XOR&#39; | &#39;⊕&#39;) (mult_term: right))
  mult_term  ::=  &lt;MULTIPLY((exp_term: left) &#39;*&#39; (exp_term: right))
  exp_term  ::=  &gt;EXPONENTIAL((_term: base) &#39;^&#39; (_term: exponent))
  nested_term  ::=  NESTED(&#39;(&#39; mset_term &#39;)&#39;)
  nullary_fun  ::=  NULLARY_FUN((ident: function_identifier) | ((ident: function_identifier) &#39;(&#39; &#39;)&#39;))
  binary_app  ::=  FUNCTION((ident: function_identifier) &#39;{&#39; (_term: argument) (&#39;,&#39; (_term: argument))*? &#39;}&#39; (_term: argument))
  nary_app  ::=  FUNCTION((ident: function_identifier) &#39;(&#39; arguments &#39;)&#39;)
  arguments  ::=  ((_term | temporal_var): argument) (&#39;,&#39; (_term: argument))*
  _literal  ::=  pub_name | fresh_name | _non_temporal_var | comp_var | _custom_type_var
  _non_temporal_var  ::=  pub_var | fresh_var | msg_var_or_nullary_fun | nat_var
  pub_var  ::=  VARIABLE((&#39;$&#39; (ident: variable_identifier) (&#39;.&#39; natural)?) | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;pub&#39;))
  fresh_var  ::=  VARIABLE((&#39;~&#39; (ident: variable_identifier) (&#39;.&#39; natural)?) | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;fresh&#39;))
  msg_var_or_nullary_fun  ::=  VARIABLE((ident: variable_identifier) (&#39;.&#39; natural)? (&#39;:&#39; &#39;msg&#39;)?)
  temporal_var  ::=  (&#39;#&#39; (ident: variable_identifier) (&#39;.&#39; natural)?) | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;node&#39;)
  nat_var  ::=  (&#39;%&#39; (ident: variable_identifier) (&#39;.&#39; natural)? (&#39;:&#39; &#39;nat&#39;)?) | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;nat&#39;)
  comp_var  ::=  &#39;=&#39; _literal
  _custom_type_var  ::=  custom_var | any_var
  custom_var  ::=  -1(_literal &#39;:&#39; (ident: variable_type))
  any_var  ::=  -1(_literal &#39;:&#39; &#39;ANY&#39;)
  temporal_var_optional_prefix  ::=  NULLARY_FUN((&#39;#&#39;? (ident: variable_identifier) (&#39;.&#39; natural)?) | ((ident: variable_identifier) (&#39;.&#39; natural)? &#39;:&#39; &#39;temporal&#39;))
  pub_name  ::=  &#39;&#39;&#39; /[^\n&#39;]+/ &#39;&#39;&#39;
  fresh_name  ::=  &#39;~&#39;&#39; /[^\n&#39;]+/ &#39;&#39;&#39;
  _formula  ::=  iff | imp | disjunction | conjunction | negation | nested_formula | _temporal_variable_operation | action_constraint | term_eq | subterm_rel | quantified_formula | atom | predicate_ref | pre_defined
  iff  ::=  &lt;LOGICAL_IFF((_formula: left) (&#39;&lt;=&gt;&#39; | &#39;⇔&#39;) (_formula: right))
  imp  ::=  &lt;LOGICAL_IMPLICATION((_formula: left) (@(1(&#39;==&gt;&#39;)) | &#39;⇒&#39;) (_formula: right))
  disjunction  ::=  &lt;LOGICAL_OR((_formula: left) (&#39;|&#39; | &#39;∨&#39;) (_formula: right))
  conjunction  ::=  &lt;LOGICAL_AND((_formula: left) (&#39;&amp;&#39; | &#39;∧&#39;) (_formula: right))
  negation  ::=  LOGICAL_NOT((&#39;not&#39; | &#39;¬&#39;) (_formula: formula))
  nested_formula  ::=  ATOM(&#39;(&#39; _formula &#39;)&#39;)
  _temporal_variable_operation  ::=  temp_var_induction | temp_var_order | temp_var_eq
  temp_var_induction  ::=  ATOM(&#39;last&#39; &#39;(&#39; temporal_var &#39;)&#39;)
  temp_var_order  ::=  ATOM(((temporal_var_optional_prefix -&gt; temporal_var): left) &#39;&lt;&#39; ((temporal_var_optional_prefix -&gt; temporal_var): right))
  temp_var_eq  ::=  ATOM(((temporal_var_optional_prefix -&gt; temporal_var): left) &#39;=&#39; ((temporal_var_optional_prefix -&gt; temporal_var): right))
  action_constraint  ::=  ATOM((_fact: fact) &#39;@&#39; ((temporal_var_optional_prefix -&gt; temporal_var): variable))
  term_eq  ::=  ATOM((_term: left) &#39;=&#39; (_term: right))
  subterm_rel  ::=  ATOM((_term: left) (&#39;&lt;&lt;&#39; | &#39;⊏&#39;) (_term: right))
  quantified_formula  ::=  ATOM((&#39;Ex&#39; | &#39;∃&#39; | &#39;All&#39; | &#39;∀&#39;) (_lvar+: variable) &#39;.&#39; (_formula: formula))
  atom  ::=  ATOM(&#39;⊥&#39; | &#39;F&#39; | &#39;⊤&#39; | &#39;T&#39;)
  _lvar  ::=  temporal_var | _non_temporal_var
  predicate_ref  ::=  FUNCTION((ident: predicate_identifier) &#39;(&#39; arguments? &#39;)&#39;)
  pre_defined  ::=  NULLARY_FUN(ident)
  hexcolor  ::=  (&#39;&#39;&#39; @(&#39;#&#39;)? @(/[0-9a-fA-F]{1,6}/) &#39;&#39;&#39;) | (@(&#39;#&#39;)? @(/[0-9a-fA-F]{1,6}/))
  ident  ::=  /[A-Za-z0-9][a-zA-Z0-9_*]*/
  param  ::=  /[^&quot;]*/
  export_query  ::=  /(\\&quot;|[^&quot;])*/
  natural  ::=  /[0-9]+/
  natural_subscript  ::=  (&#39;₀&#39; | &#39;₁&#39; | &#39;₂&#39; | &#39;₃&#39; | &#39;₄&#39; | &#39;₅&#39; | &#39;₆&#39; | &#39;₇&#39; | &#39;₈&#39; | &#39;₉&#39;)+
  formal_comment  ::=  (ident: comment_identifier) @(&#39;{*&#39; /[^*]*\*+([^}*][^*]*\*+)*/ &#39;}&#39;)</code></pre>
    </div>
  </div>
</body>

</html>
