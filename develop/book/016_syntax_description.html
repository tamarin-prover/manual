<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamarin Prover Manual</title>
  <link rel="stylesheet" type="text/css" href="book.css">
  <script src="book.js"></script>
  <link rel="stylesheet" href="styles/github.css">
  <!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
  </head>

<body class="tamarindoc">
  <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
      <span class="sr-only">Toggle navigation</span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
    <ul class='chapter'>
      <!-- <li><a href='000_prelims.html'><b>0. </b>Preliminaries</a></li> -->
      <li><a href='001_introduction.html'><b>1. </b> Introduction</a></li>
      <li><a href='002_installation.html'><b>2. </b> Installation</a></li>
      <li><a href='003_example.html'><b>3. </b> First Example</a></li>
      <li><a href='004_cryptographic-messages.html'><b>4. </b> Cryptographic Messages</a></li>
      <li><a href='005_protocol-specification-rules.html'><b>5. </b> Protocol Specification using Rules</a></li>
      <li><a href='006_protocol-specification-processes.html'><b>6. </b> Protocol Specification using Processes</a></li>
      <li><a href='007_property-specification.html'><b>7. </b> Property Specification</a></li>
      <li><a href='008_accountability.html'><b>8. </b> Accountability</a></li>
      <li><a href='009_precomputation.html'><b>9. </b> Precomputation</a></li>
      <li><a href='010_modeling-issues.html'><b>10. </b> Modeling Issues</a></li>
      <li><a href='011_advanced-features.html'><b>11. </b> Advanced Features</a></li>
      <li><a href='012_case-studies.html'><b>12.</b> Case Studies</a></li>
      <li><a href='013_toolchains.html'><b>13.</b> Toolchains</a></li>
      <li><a href='014_limitations.html'><b>14.</b> Limitations</a></li>
      <li><a href='015_contact-and-further-reading.html'><b>15.</b> Contact Information and Further Reading</a></li>
      <li><a href='016_syntax_description.html'><b>16.</b> Syntax Description</a></li>
    </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
      <p class="halfbreak">
      </p>
      <h1 id="syntax-description">Syntax Description</h1>
      <p>Here, we explain the formal syntax of the security protocol
      theory format that is processed by Tamarin.</p>
      <p>Comments are C-style:</p>
      <pre><code>/* for a multi-line comment */
// for a line-comment</code></pre>
      <p>All security protocol theory are named and delimited by
      <code>begin</code> and <code>end</code>. We explain the
      non-terminals of the body in the following paragraphs.</p>
      <pre><code>security_protocol_theory := &#39;theory&#39; ident &#39;begin&#39; body &#39;end&#39;
body := (signature_spec | global_heuristic | tactic | rule |
            restriction | lemma | formal_comment)*</code></pre>
      <p>Here, we use the term signature more liberally to denote both
      the defined function symbols and the equalities describing their
      interaction. Note that our parser is stateful and remembers what
      functions have been defined. It will only parse function
      applications of defined functions.</p>
      <pre><code>signature_spec := functions | equations | built_in
functions      := &#39;functions&#39; &#39;:&#39; function_sym (&#39;,&#39; function_sym)* [&#39;,&#39;]
function_sym   := ident &#39;/&#39; arity [&#39;[private]&#39;]
arity          := digit+
equations      := &#39;equations&#39; &#39;:&#39; equation (&#39;,&#39; equation)* [&#39;,&#39;]
equation       := (term &#39;=&#39; term)</code></pre>
      <p>Note that the equations must be convergent and have the Finite
      Variant Property (FVP), and do not allow the use of fixed public
      names in the terms. Tamarin provides built-in sets of function
      definitions and equations. They are expanded upon parsing and you
      can therefore inspect them by pretty printing the file using
      <code>tamarin-prover your_file.spthy</code>. The built-in
      <code>diffie-hellman</code> is special. It refers to the equations
      given in Section <a
      href="004_cryptographic-messages.html#sec:equational-theories">Cryptographic
      Messages</a>. You need to enable it to parse terms containing
      exponentiations, e.g., g ^ x.</p>
      <pre><code>built_in       := &#39;builtins&#39; &#39;:&#39; built_ins (&#39;,&#39; built_ins)* [&#39;,&#39;]
built_ins      := &#39;diffie-hellman&#39;
                | &#39;hashing&#39; | &#39;symmetric-encryption&#39;
                | &#39;asymmetric-encryption&#39; | &#39;signing&#39;
                | &#39;bilinear-pairing&#39; | &#39;xor&#39;
                | &#39;multiset&#39; | &#39;natural-numbers&#39; | &#39;revealing-signing&#39;</code></pre>
      <p>A global heuristic sets the default heuristic that will be used
      when autoproving lemmas in the file. The specified goal ranking
      can be any of those discussed in Section <a
      href="010_advanced-features.html#sec:heuristics">Heuristics</a>.</p>
      <pre><code>global_heuristic      := &#39;heuristic&#39; &#39;:&#39; goal_ranking+
goal_ranking          := standard_goal_ranking | oracle_goal_ganking
standard_goal_ranking := &#39;C&#39; | &#39;I&#39; | &#39;P&#39; | &#39;S&#39; | &#39;c&#39; | &#39;i&#39; | &#39;p&#39; | &#39;s&#39;
oracle_goal_ranking   := &#39;o&#39; &#39;&quot;&#39; [^&#39;&quot;&#39;]* &#39;&quot;&#39; | &#39;O&#39; &#39;&quot;&#39; [^&#39;&quot;&#39;]* &#39;&quot;&#39;</code></pre>
      <p>The tactics allow the user to write their own heuristics based
      on the lemmas there are trying to prove. Their use is descibed in
      in Section <a
      href="010_advanced-features.html#sec:fact-annotations#subsec:tactic">Using
      a Tactic</a>.</p>
      <pre><code>tactic                := &#39;tactic&#39; &#39;:&#39; ident
                         [presort]
                         (prio)+ (deprio)* | (prio)* (deprio)+
presort               := &#39;presort&#39; &#39;:&#39; &#39;standard_goal_ranking
prio                  := &#39;prio&#39; &#39;:&#39; [&#39;{&#39;post_ranking&#39;}&#39;]
                             (function)+
deprio                := &#39;deprio&#39; &#39;:&#39; [&#39;{&#39;post_ranking&#39;}&#39;]
                             (function)+
standard_goal_ranking := &#39;C&#39; | &#39;I&#39; | &#39;P&#39; | &#39;S&#39; | &#39;c&#39; | &#39;i&#39; | &#39;p&#39; | &#39;s&#39;
post_ranking          := &#39;smallest&#39; | &#39;id&#39;                   
function              := and_function [ &#39;|&#39; and_function]*
and_function          := not_function [ &#39;&amp;&#39; not_function]*
not_function          := (not)? function_name [&#39;&quot;&#39; param &#39;&quot;&#39;]*
function_name         :=   &#39;regex&#39; | &#39;isFactName&#39; | &#39;isInFactTerms&#39; | &#39;dhreNoise&#39;
                         | &#39;defaultNoise&#39; | &#39;reasonableNoncesNoise&#39; | &#39;nonAbsurdGoal&#39;</code></pre>
      <p>Multiset rewriting rules are specified as follows. The protocol
      corresponding to a security protocol theory is the set of all
      multiset rewriting rules specified in the body of the theory. Rule
      variants can be explicitly given, as well as the left and right
      instances of a rule in diff-mode. (When called with
      <code>--diff</code>, Tamarin will parse <code>diff_rule</code>
      instead of <code>rule</code>).</p>
      <pre><code>rule        := simple_rule [variants]
diff_rule   := simple_rule [&#39;left&#39; rule &#39;right&#39; rule]
simple_rule := &#39;rule&#39; [modulo] ident [rule_attrs] &#39;:&#39;
        [let_block]
        &#39;[&#39; facts &#39;]&#39; ( &#39;--&gt;&#39; | &#39;--[&#39; facts &#39;]-&gt;&#39;) &#39;[&#39; facts &#39;]&#39;
variants    := &#39;variants&#39; simple_rule (&#39;,&#39; simple_rule)*
modulo      := &#39;(&#39; &#39;modulo&#39; (&#39;E&#39; | &#39;AC&#39;) &#39;)&#39;
rule_attrs  := &#39;[&#39; rule_attr (&#39;,&#39; rule_attr)* [&#39;,&#39;] &#39;]&#39;
rule_attr   := (&#39;color=&#39; | &#39;colour=&#39;) hexcolor
let_block   := &#39;let&#39; (msg_var &#39;=&#39; msetterm)+ &#39;in&#39;
msg_var     := ident [&#39;.&#39; natural] [&#39;:&#39; &#39;msg&#39;]
hexcolor    := &quot;&#39;&quot; [&quot;#&quot;] hexdigit{6} &quot;&#39;&quot; | [&quot;#&quot;] hexdigit{6}</code></pre>
      <p>Rule annotations do not influence the rule’s semantics. A color
      is represented as a triplet of 8 bit hexadecimal values optionally
      preceded by ‘#’, and is used as the background color of the rule
      when it is rendered in graphs.</p>
      <p>The let-block allows more succinct specifications. The
      equations are applied in a bottom-up fashion. For example,</p>
      <pre><code>let x = y
    y = &lt;z,x&gt;
in [] --&gt; [ A(y)]    is desugared to    [] --&gt; [ A(&lt;z,y&gt;) ]</code></pre>
      <p>This becomes a lot less confusing if you keep the set of
      variables on the left-hand side separate from the free variables
      on the right-hand side.</p>
      <p>Macros works similarly to let-blocks, but apply globally to all
      rules.</p>
      <pre><code>macros      := &#39;macros&#39; &#39;:&#39; macro (&#39;,&#39; macro)*
macro       := ident &#39;(&#39; [(var) (&#39;,&#39; var)*] &#39;)&#39; &#39;=&#39; term</code></pre>
      <p>Configuration blocks allow the specification of certain Tamarin
      command line options in the model file itself. Options passed over
      the command line override options given in a configuration
      block.</p>
      <pre><code>configuration := &#39;configuration&#39; &#39;:&#39; &#39;&quot;&#39; option (&#39; &#39; option)* &#39;&quot;&#39;
option          := &#39;--auto-sources&#39; | (&#39;--stop-on-trace&#39; &#39;=&#39; search_method)
search_method := &#39;DFS&#39; | &#39;BFS&#39; | &#39;SEQDFS&#39; | &#39;NONE&#39;</code></pre>
      <p>Restrictions specify restrictions on the set of traces
      considered, i.e., they filter the set of traces of a protocol. The
      formula of a restriction is available as an assumption in the
      proofs of <em>all</em> security properties specified in this
      security protocol theory.</p>
      <pre><code>restriction := &#39;restriction&#39; ident &#39;:&#39; &#39;&quot;&#39; formula &#39;&quot;&#39;</code></pre>
      <p>In observational equivalence mode, restrictions can be
      associated to one side.</p>
      <pre><code>restriction := &#39;restriction&#39; ident [restriction_attrs] &#39;:&#39; &#39;&quot;&#39; formula &#39;&quot;&#39;
restriction_attrs      := &#39;[&#39; (&#39;left&#39; | &#39;right&#39;) &#39;]&#39;</code></pre>
      <p>Lemmas specify security properties. By default, the given
      formula is interpreted as a property that must hold for all traces
      of the protocol of the security protocol theory. You can change
      this using the ‘exists-trace’ trace quantifier.</p>
      <pre><code>lemma := &#39;lemma&#39; [modulo] ident [lemma_attrs] &#39;:&#39;
         [trace_quantifier]
         &#39;&quot;&#39; formula &#39;&quot;&#39;
         proof_skeleton
lemma_attrs      := &#39;[&#39; lemma_attr (&#39;,&#39; lemma_attr)* [&#39;,&#39;] &#39;]&#39;
lemma_attr       := &#39;sources&#39; | &#39;reuse&#39; | &#39;use_induction&#39; |
                         &#39;hide_lemma=&#39; ident | &#39;heuristic=&#39; goalRanking+
trace_quantifier := &#39;all-traces&#39; | &#39;exists-trace&#39;</code></pre>
      <p>In observational equivalence mode, lemmas can be associated to
      one side.</p>
      <pre><code>lemma_attr      := &#39;[&#39; (&#39;sources&#39; | &#39;reuse&#39; | &#39;use_induction&#39; |
                        &#39;hide_lemma=&#39; ident | &#39;heuristic=&#39; heuristic |
                        &#39;left&#39; | &#39;right&#39;) &#39;]&#39;</code></pre>
      <p>A proof skeleton is a complete or partial proof as output by
      the Tamarin prover. It indicates the proof method used at each
      step, which may include multiple cases.</p>
      <pre><code>proof_skeleton :=  &#39;SOLVED&#39; | &#39;by&#39; proof_method
                | proof_method proof_skeleton
                | proof_method &#39;case&#39; ident proof_skeleton
                    (&#39;next &#39;case&#39; ident proof_skeleton)* &#39;qed&#39;
proof_method   := &#39;sorry&#39; | &#39;simplify&#39; | &#39;solve &#39;(&#39; goal &#39;)&#39; |
                  &#39;contradiction&#39; | &#39;induction&#39;
goal           :=  fact &quot;▶&quot; natural_subscr node_var
                | fact &#39;@&#39; node_var
                | &#39;(&#39; node_var &#39;,&#39; natural &#39;)&#39; &#39;~~&gt;&#39; &#39;(&#39; node_var &#39;,&#39; natural &#39;)&#39;
                | formula (&quot;∥&quot; formula)*
                | &#39;splitEqs&#39; &#39;(&#39; natural &#39;)&#39;
node_var       := [&#39;#&#39;] ident [&#39;.&#39; natural]      // temporal sort prefix
                | ident [&#39;.&#39; natural] &#39;:&#39; &#39;node&#39; // temporal sort suffix
natural        := digit+
natural_subscr := (&#39;₀&#39;|&#39;₁&#39;|&#39;₂&#39;|&#39;₃&#39;|&#39;₄&#39;|&#39;₅&#39;|&#39;₆&#39;|&#39;₇&#39;|&#39;₈&#39;|&#39;₉&#39;)+</code></pre>
      <p>Formal comments are used to make the input more readable. In
      contrast to <code>/*...*/</code> and <code>//...</code> comments,
      formal comments are stored and output again when pretty-printing a
      security protocol theory.</p>
      <pre><code>formal_comment := ident &#39;{*&#39; ident* &#39;*}&#39;</code></pre>
      <p>For the syntax of terms, you best look at our examples. A
      common pitfall is to use an undefined function symbol. This
      results in an error message pointing to a position slightly before
      the actual use of the function due to some ambiguity in the
      grammar.</p>
      <p>We provide special syntax for tuples, multisets, xors,
      multiplications, exponentiation, nullary and binary function
      symbols. An n-ary tuple <code>&lt;t1,...,tn&gt;</code> is parsed
      as n-ary, right-associative application of pairing. Multiplication
      and exponentiation are parsed left-associatively. For a binary
      operator <code>enc</code> you can write <code>enc{m}k</code> or
      <code>enc(m,k)</code>. For nullary function symbols, there is no
      need to write <code>nullary()</code>. Note that the number of
      arguments of an n-ary function application must agree with the
      arity given in the function definition.</p>
      <pre><code>tupleterm := &#39;&lt;&#39; msetterm (&#39;,&#39; msetterm)* &#39;&gt;&#39;
msetterm  := natterm ((&#39;++&#39; | &#39;+&#39;) natterm)*
natterm   := xorterm (&#39;%+&#39; xorterm)*
xorterm   := multterm ((&#39;XOR&#39; | ⊕) multterm)*
multterm  := expterm (&#39;*&#39; expterm)*
expterm   := term    (&#39;^&#39; term   )*
term      := tupleterm             // n-ary right-associative pairing
           | &#39;(&#39; msetterm &#39;)&#39;      // a nested term
           | nullary_fun
           | binary_app
           | nary_app
           | literal

nullary_fun := &lt;all-nullary-functions-defined-up-to-here&gt;
binary_app  := binary_fun &#39;{&#39; tupleterm &#39;}&#39; term
binary_fun  := &lt;all-binary-functions-defined-up-to-here&gt;
nary_app    := nary_fun &#39;(&#39; multterm* &#39;)&#39;

literal     := &quot;&#39;&quot;  ident &quot;&#39;&quot; // a fixed, public name
             | &quot;~&#39;&quot; ident &quot;&#39;&quot; // a fixed, fresh name
             | nonnode_var    // a non-temporal variable
nonnode_var := [&#39;$&#39;] ident [&#39;.&#39; natural]         // &#39;pub&#39; sort prefix
             | ident [&#39;.&#39; natural] &#39;:&#39; &#39;pub&#39;     // &#39;pub&#39; sort suffix
             | [&#39;~&#39;] ident [&#39;.&#39; natural]         // &#39;fresh&#39; sort prefix
             | ident [&#39;.&#39; natural] &#39;:&#39; &#39;fresh&#39;   // &#39;fresh&#39; sort suffix
             | msg_var                                // &#39;msg&#39; sort</code></pre>
      <p>Facts do not have to be defined up-front. This will probably
      change once we implement user-defined sorts. Facts prefixed with
      <code>!</code> are persistent facts. All other facts are linear.
      There are six reserved fact symbols: In, Out, KU, KD, Fr, and K.
      KU and KD facts are used for construction and deconstruction
      rules. KU-facts also log the messages deduced by construction
      rules. Note that KU-facts have arity 2. Their first argument is
      used to track the exponentiation tags. See the
      <code>loops/Crypto_API_Simple.spthy</code> example for more
      information.</p>
      <pre><code>facts := fact (&#39;,&#39; fact)*
fact  := [&#39;!&#39;] ident &#39;(&#39; [msetterm (&#39;,&#39; msetterm)*] &#39;)&#39; [fact_annotes]
fact_annotes := &#39;[&#39; fact_annote (&#39;,&#39; fact_annote)* &#39;]&#39;
fact_annote  := &#39;+&#39; | &#39;-&#39; | &#39;no_precomp&#39;</code></pre>
      <p>Fact annotations can be used to adjust the priority of
      corresponding goals in the heuristics, or influence the
      precomputation step performed by Tamarin, as described in Section
      <a href="010_advanced-features.html#sec:fact-annotations">Advanced
      Features</a>.</p>
      <p>Formulas are trace formulas as described previously. Note that
      we are a bit more liberal with respect to guardedness. We accept a
      conjunction of atoms as guards.</p>
      <pre><code>formula     := imp [(&#39;&lt;=&gt;&#39; | &#39;⇔&#39;) imp]
imp         := disjunction [(&#39;==&gt;&#39; | &#39;⇒&#39;) imp]
disjunction := conjunction ((&#39;|&#39; | &#39;∨&#39;) conjunction)* // left-associative
conjunction := negation ((&#39;&amp;&#39; | &#39;∧&#39;) negation)*       // left-associative
negation    := [&#39;not&#39; | &#39;¬&#39;] atom
atom        := &#39;⊥&#39; | &#39;F&#39; | &#39;⊤&#39; | &#39;T&#39;           // true or false
             | &#39;(&#39; formula &#39;)&#39;                 // nested formula
             | &#39;last&#39; &#39;(&#39; node_var &#39;)&#39;         // &#39;last&#39; temporal variable for induction
             | fact &#39;@&#39; node_var               // action
             | node_var &#39;&lt;&#39; node_var           // ordering of temporal variables
             | msetterm &#39;=&#39; msetterm           // equality of terms
             | msetterm (&#39;&lt;&lt;&#39; | &#39;⊏&#39;) msetterm  // subterm relation
             | node_var &#39;=&#39; node_var           // equality of temporal variables
             | (&#39;Ex&#39; | &#39;∃&#39; | &#39;All&#39; | &#39;∀&#39;)      // quantified formula
                    lvar+ &#39;.&#39; formula

lvar        := node_var | nonnode_var</code></pre>
      <p>Identifiers always start with a letter or number, and may
      contain underscores after the first character. Moreover, they must
      not be one of the reserved keywords <code>let</code>,
      <code>in</code>, or <code>rule</code>. Although identifiers
      beginning with a number are valid, they are not allowed as the
      names of facts (which must begin with an upper-case letter). ident
      := alphaNum (alphaNum | ’_’)*</p>
    </div>
  </div>
</body>

</html>
