<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamarin Prover Manual</title>
  <link rel="stylesheet" type="text/css" href="book.css">
  <script src="book.js"></script>
  <link rel="stylesheet" href="styles/github.css">
  <!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
    <script
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
  </head>

<body class="tamarindoc">
  <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
      <span class="sr-only">Toggle navigation</span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
    <ul class='chapter'>
      <!-- <li><a href='000_prelims.html'><b>0. </b>Preliminaries</a></li> -->
      <li><a href='001_introduction.html'><b>1. </b> Introduction</a></li>
      <li><a href='002_installation.html'><b>2. </b> Installation</a></li>
      <li><a href='003_example.html'><b>3. </b> First Example</a></li>
      <li><a href='004_cryptographic-messages.html'><b>4. </b> Cryptographic Messages</a></li>
      <li><a href='005_protocol-specification-rules.html'><b>5. </b> Protocol Specification using Rules</a></li>
      <li><a href='006_protocol-specification-processes.html'><b>6. </b> Protocol Specification using Processes</a></li>
      <li><a href='007_property-specification.html'><b>7. </b> Property Specification</a></li>
      <li><a href='008_accountability.html'><b>8. </b> Accountability</a></li>
      <li><a href='009_precomputation.html'><b>9. </b> Precomputation</a></li>
      <li><a href='010_modeling-issues.html'><b>10. </b> Modeling Issues</a></li>
      <li><a href='011_advanced-features.html'><b>11. </b> Advanced Features</a></li>
      <li><a href='012_case-studies.html'><b>12.</b> Case Studies</a></li>
      <li><a href='013_toolchains.html'><b>13.</b> Toolchains</a></li>
      <li><a href='014_limitations.html'><b>14.</b> Limitations</a></li>
      <li><a href='015_contact-and-further-reading.html'><b>15.</b> Contact Information and Further Reading</a></li>
      <li><a href='016_syntax_description.html'><b>16.</b> Syntax Description</a></li>
    </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
      <p class="halfbreak">
      </p>
      <h1 id="sec:model-specification-proc">Model Specification using
      Processes</h1>
      <p>In this section, we provide an informal description of the
      process calculus now integrated in tamarin. It is called
      <strong>SAPIC+</strong>, which stands for “Stateful Applied
      PI-Calculus” (plus) and is described in the following papers:</p>
      <ul>
      <li><p><span class="citation" data-cites="KK-jcs16">(Kremer and
      Künnemann 2016)</span> introduced the original version of SAPIC
      and its translation to multiset rewrite rules and axioms.</p></li>
      <li><p><span class="citation"
      data-cites="BaDrKr-2016-liveness">(Backes et al. 2017)</span>
      added non-deterministic choice, reliable channels and <a
      href="#sec:local-progress">local progress</a> to it.</p></li>
      <li><p><span class="citation"
      data-cites="jacomme2017symbolic">(Jacomme, Kremer, and Scerri
      2017)</span> added support for <a href="#sec:iee">isolated
      execution environments</a>.</p></li>
      <li><p><span class="citation" data-cites="sapicplus">(Cheval et
      al. 2022)</span> extended SAPIC to SAPIC+, introducing the new
      syntax that we will introduce in the followup and <a
      href="#sec:translation">translations to various
      tools</a>.</p></li>
      </ul>
      <p>A Protocol can be modelled in terms of rules or as a (single)
      process. The process is translated into a set of rules that adhere
      to the semantics of the process calculus. It is even possible to
      mix a process declaration and a set of rules, although this is not
      recommended, as the interactions between the rules and the process
      depend on how precisely this translation is defined.</p>
      <h2 id="sec:proc">Processes</h2>
      <p>A SAPIC+ process is described using the grammar we will
      introduce and illustrate by example in the followup. Throughout,
      let <code>n</code> stand for a fresh name, <code>x</code> for a
      variable, <code>t</code>, <code>t1</code> or <code>t2</code> for
      terms and <code>F</code> for a fact and <code>cond</code> for a
      conditional, which is either a comparisson <code>t1=t2</code> or a
      custom <a
      href="007_property-specification.html#sec:predicates">predicate</a>.</p>
      <h3 id="standard-applied-pi-features">Standard applied-pi
      features</h3>
      <p>The main ingredients for modelling protocols are network
      communication and parallelism. We start with the network
      communication and other constructs that model local operation and
      call this simpler form of a process, <em>elementary
      processes</em>:</p>
      <pre><code>&lt;P,Q&gt; :: =  (elementary processes)
    new n; P                .. binding of a fresh name
  | out(t1,t2); P           .. output of t2 on a channel t1
  | out(t); P               .. output of t on the public channel
  | in(t,x);~P              .. input on channel t binding input term to $x$}
  | in(x);~P                .. input on the public channel binding to $x$}
  | if cond then P else Q   .. conditional
  | let t1 = t2 in P else Q .. let binding
  | P | Q                   .. parallel composition
  | 0                       .. null process</code></pre>
      <p>The construct <code>new a;P</code> binds the fresh name
      <code>a</code> in <code>P</code>. Similar to the fact
      <code>Fr(a)</code>, it models the generation of a fresh, random
      value.</p>
      <p>The processes <code>out(t1,t2); P</code> represent the output
      of a message <code>t2</code> on a channel <code>t1</code>, whereas
      <code>in(t,x); P</code> represents a process waiting to bind some
      input on channel <code>t</code> to the variable <code>x</code>.
      (Previous versions of SAPIC performed pattern matching. Instead,
      the <code>let</code> construct offers support for pattern matching
      and, similar to the applied pi calculus <span class="citation"
      data-cites="AF-popl01">(Abadi and Fournet 2001)</span>, we bind to
      a variable.</p>
      <p>If the channel is left out, the public channel <code>'c'</code>
      is assumed, which is the case in the majority of our examples.
      This is exactly what the facts <code>In(x)</code> and
      <code>Out(t)</code> represent.</p>
      <p><strong>Example.</strong> This process picks an encryption key,
      waits for an input and encrypts it.</p>
      <pre><code>new k; in(m); out(senc(m,k))</code></pre>
      <p>Processes can also branch: <code>if cond then P else Q</code>
      will execute either <code>P</code> or <code>Q</code>, depending on
      whether <code>cond</code> holds. Most frequently, this is the
      equality check of form <code>t1 = t2</code>, but you can also
      define <a href="007_property-specification.html#sec:predicates">a
      predicate</a> using Tamarin’s security property syntax.</p>
      <p><code>Let</code>-bindings are allowed to faciliate writing
      processes where a term occur several times (possibly as a subterm)
      within the process rule and to apply destructors. Destructor are
      function symbols declared as such, e.g.:</p>
      <pre><code>functions: adec/2[destructor], aenc/2
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1</code></pre>
      <p>declares a destructor <code>adec</code>. In contrast to the
      encryption (represented by <code>aenc</code>), the decryption may
      fail, e.g., the term <code>adec(aenc(m,pk(sk)),sk')</code> is not
      representing a valid message. A destructor symbol allows to
      represent this failure. Destructors may only appear in
      <code>let</code>-patterns (i.e., to the right of <code>=</code>).
      If one of the destructors in a let pattern fails, the process
      moves into the else branch, e.g.,</p>
      <pre><code>new sk; new sk&#39;; let x=adec(aenc(m,pk(sk)),sk&#39;) in P else Q</code></pre>
      <p>always moves into <code>Q</code>. Destructors cannot appear
      elsewhere in the process.</p>
      <p>Furthermore, <code>let</code>-bindings permit pattern matching.
      This is very useful for deconstructing messages. E.g.:</p>
      <pre><code>in(x); let &lt;&#39;pair&#39;,y,z&gt; = x in out(z); out(z)</code></pre>
      <p>To avoid user errors, pattern matchings are explicit in which
      variables they bind and which they compare for equality, e.g.,
      <code>let &lt;y,=z&gt;=x in ..</code> checks if <code>x</code> is
      a pair and if the second element equals <code>z</code>; then it
      binds the first element to x. (Note: previous versions of
      Tamarin/SAPIC considered let-bindings as syntactic sugar adhering
      to the same rules as <a href="#sec:let-rules">let-bindings in
      rules</a>. Now <code>let</code> is a first-class primitive. )</p>
      <p>The types of processes so far consists of actions that are
      separated with a semicolon <code>;</code> and are terminated with
      <code>0</code>, which is called the terminal process or null
      process. This is a process that does nothing. It is allowed to
      omit trailing <code>0</code> processes and
      <code>else</code>-branches that consist of a <code>0</code>
      process.</p>
      <p>We can now come to the operations modelling parallelism.
      <code>P | Q</code> is the parallel execution of processes P and Q.
      This is used, e.g., to model two participants in a protocol.</p>
      <p><code>P+Q</code> denotes external non-deterministic choice,
      which can be used to model alternatives. In that sense, it is
      closer to a condition rather than two processes running in
      parallel: <code>P+Q</code> reduces to <em>either</em>
      <code>P'</code> or <code>Q'</code>, the follow-up processes or
      <code>P</code> or <code>Q</code> respectively.</p>
      <p>Now we come to <em>extended processes</em>, that include
      standard processes, but also events and replications.</p>
      <pre><code>&lt;P&gt; :==    (extended processes)
  | event F; P  .. event   
  | !P .. replication</code></pre>
      <p>The <code>event</code> construct is similar to actions in
      rules. In fact, it will be translated to actions. Like in rules,
      events annotate parts of the processes and are useful for stating
      security properties. Each of these constructs can be thought of as
      “local” computations.</p>
      <p><code>!P</code> is the replication of P, which allows an
      unbounded number of sessions in protocol executions. It can be
      thought of to be an infinite number of processes
      <code>P | .. | P</code> running in parallel. If <code>P</code>
      describes a webserver answering a single query, then
      <code>!P</code> is the webserver answering queries
      indefinitely.</p>
      <h3 id="manipulation-of-global-state">Manipulation of global
      state</h3>
      <p>The SAPIC+ calculus is a dialect of the applied-pi calculus
      with additional features for storing, retrieving and modifying
      global state. <em>Stateful process</em> include extended processes
      and, in addition, the remaining constructs that are used to
      manipulate global state.</p>
      <pre><code>&lt;P,Q&gt; :==        (stateful processes)
  | insert t1, t2; P .. set state t1 to t2
  | delete t; P  .. delete state t
  | lookup t as x in P else Q ; P  .. read state t into variable x
  | lock t; P .. set lock on t
  | unlock t; P .. remove lock on t</code></pre>
      <p>The construct <code>insert t1,t2; P</code> binds the value
      <code>t2</code> to the key <code>t1</code>. Successive inserts
      overwrite this binding. The store is global, but as
      <code>t1</code> is a term, it can be used to define name spaces.
      E.g., if a webserver is identified by a name <code>w_id</code>,
      then it could prefix it’s store as follows:
      <code>insert &lt;'webservers',w_id,'store'&gt;, data; P</code>.</p>
      <p>The construct <code>delete t; P</code> ‘undefines’ the
      binding.</p>
      <p>The construct <code>lookup t as x in P else Q</code> allows for
      retrieving the value associated to <code>t</code> and binds it to
      the variable <code>x</code> when entering <code>P</code>. If the
      mapping is undefined for <code>t</code>, the process behaves as
      <code>Q</code>.</p>
      <p>The <code>lock</code> and <code>unlock</code> constructs are
      used to gain or waive exclusive access to a resource
      <code>t</code>, in the style of Dijkstra’s binary semaphores: if a
      term <code>t</code> has been locked, any subsequent attempt to
      lock <code>t</code> will be blocked until <code>t</code> has been
      unlocked. This is essential for writing protocols where parallel
      processes may read and update a common memory.</p>
      <h3 id="inline-multiset-rewrite-rules">Inline multiset-rewrite
      rules</h3>
      <p>There is a hidden feature for experts: inline multiset-rewrite
      rules: <code>[l] --[a]-&gt; r; P</code> is a valid process.
      Embedded rules apply if their preconditions apply (i.e., the facts
      on the left-hand-side are present) <strong>and</strong> the
      process is reduced up to this rule. If the rule applies in the
      current state, the process reduces to <code>P</code>. We advice to
      avoid these rules whenever possible, as they run counter to the
      aim of SAPIC: to provide clear, provably correct high-level
      abstractions for the modelling of protocols. Note also that the
      state-manipulation constructs <code>lookup x as v</code>,
      <code>insert x,y</code> and <code>delete x</code> manage state by
      emitting actions <code>IsIn(x,y')</code>, <code>Insert(x,y)</code>
      and <code>Delete(x)</code> and enforcing their proper semantics
      via restrictions. For example: an action <code>IsIn(x,y)</code>,
      which expresses a succesful lookup, requires that an action
      <code>Insert(x,y)</code> has occurred previously, and in between,
      no other <code>Insert(x,y')</code> or <code>Delete(x)</code>
      action has changed the global store at the position
      <code>x</code>. Hence, the global store is distinct from the set
      of facts in the current state.</p>
      <h3 id="sec:local-progress">Enforcing local progress
      (optional)</h3>
      <p>The translation from processes can be modified so it enforces a
      different semantics. In this semantics, the set of traces consists
      of only those where a process has been reduced <strong>as far as
      possible</strong>. A process can reduce unless it is waiting for
      some input, it is under replication, or unless it is already
      reduced up to the 0-process.</p>
      <pre><code>options: translation-progress</code></pre>
      <p>This can be used to model time-outs. The following process must
      reduce to either <code>P</code> or <code>out('help');0</code>:</p>
      <pre><code>( in(x); P) + (out(&#39;help&#39;);0)</code></pre>
      <p>If the input message received, it will produce regulary, in
      this example: with <code>P</code>. If the input is not received,
      there is no other way to progress except for the right-hand side.
      But progress it must, so the right-hand side can model a recovery
      protocol.</p>
      <p>In the translated rules, events <code>ProgressFrom_p</code> and
      <code>ProgressTo_p</code> are added. Here <code>p</code> marks a
      position that, one reached, requires the corresponding
      <code>ProgressTo</code> event to appear. This is enforced by
      restrictions. Note that a process may need to process to more than
      one position, e.g.,</p>
      <pre><code>new a; (new b; 0 | new c; 0)</code></pre>
      <p>progresses to both trailing 0-processes.</p>
      <p>It may also process to one out of many positions, e.g.,
      here</p>
      <pre><code>in(x); if x=&#39;a&#39; then 0 else 0</code></pre>
      <p>More details can be found in the corrsponding paper <span
      class="citation" data-cites="BaDrKr-2016-liveness">(Backes et al.
      2017)</span>. Note that local progress by itself does not
      guarantee that messages arrive. Recovery protocols often rely on a
      trusted third party, which is possibly offline most of time, but
      can be reached using <a
      href="004_cryptographic-messages.html#sec:builtin-theories">the
      builtin theory for reliable channels</a>.</p>
      <h3 id="sec:iee">Modeling Isolated Execution Environments</h3>
      <p>IEEs, or enclaves, allow to run code inside a secure
      environment and to provide a certificate of the current state
      (including the executed program) of the enclave. A localized
      version of the applied pi-calculus, defined in <span
      class="citation" data-cites="jacomme2017symbolic">(Jacomme,
      Kremer, and Scerri 2017)</span> and included in SAPIC, allows to
      model such environments.</p>
      <p>Processes can be given a unique identifier, which we call
      location:</p>
      <pre><code>let A = (...)@loc</code></pre>
      <p>Locations can be any term (which may depend on previous
      inputs). A location is an identifier which allows to talk about
      its process. Inside a location, a report over some value can be
      produced:</p>
      <pre><code>(...
let x=report(m) in
   ...)@loc</code></pre>
      <p>Some external user can then verify that some value has been
      produced at a specific location, i.e produced by a specific
      process or program, by using the <code>check_rep</code>
      function:</p>
      <pre><code>if input=check_rep(rep,loc) then</code></pre>
      <p>This will be valid only if <code>rep</code> has been produced
      by the previous instruction, with <code>m=input</code>.</p>
      <p>An important point about enclaves is that any user, e.g an
      attacker, can use enclaves, and thus produce reports for its own
      processes or locations. But if the attacker can produce a report
      for any location, he can break all security properties associated
      to it. To this end, the user can define a set of untrusted
      locations, which amounts to defining a set of processes that he
      does not trust, by defining a builtin <code>Report</code>
      predicate:</p>
      <pre><code>predicates:
Report(x,y) &lt;=&gt; phi(x,y)</code></pre>
      <p>The attacker can then produce any <code>report(m)@loc</code> if
      <code>phi(m,loc)</code> is true.</p>
      <p>More details can be found in the corresponding paper <span
      class="citation" data-cites="jacomme2017symbolic">(Jacomme,
      Kremer, and Scerri 2017)</span>, and the examples.</p>
      <h2 id="process-declarations-using-let">Process declarations using
      <code>let</code></h2>
      <p>It is advisable to structure processes around the protocol
      roles they represent. These can be declared using the let
      construct:</p>
      <pre><code>let Webserver (identity) = in(&lt;&#39;Get&#39;,identity..&gt;); ..

let Webbrowser () = ..

(! new identity !Webserver(identity)) | ! Webbroser</code></pre>
      <p>These can be nested, i.e., this is valid:</p>
      <pre><code>let A() = ..
let B() = A() | A()
!B()</code></pre>
      <h2 id="typing">Typing</h2>
      <p>It is possible to declare types to avoid potential user errors.
      This does not affect the attacker, as these types are disregarded
      after translation into multiset-rewrite rues.</p>
      <p>Types can be declared for function symbols:</p>
      <pre class="spthy"><code>functions: f(bitstring):bitstring, g(lol):lol,
            h/1 // will implicitely typed later.</code></pre>
      <p>for processes:</p>
      <pre><code>new x:lol;                             // x is of type lol now
new y;                                 // y&#39;s type will be inferred
out(f(y));                             // now y must be type bitstring ...
// out(f(x));                          // fails: f expects bitstring
out(&lt;x,y&gt;); out(x + y); out(f(&lt;x,y&gt;)); // lists and AC operators are type-transparent
out(h(h(x)));                          // implictely types h as lol-&gt;lol
// out(f(h(x)));                       // fails: as h goes to lol and f wants bitstring</code></pre>
      <p>and subprocesses:</p>
      <pre><code>let P(a:lol) =</code></pre>
      <h2 id="sec:translation">Export features</h2>
      <p>It is possible to export processes defined in .spthy files into
      the formats used by other protocol verifiers, making it possible
      to switch between tools. One can even translate lemmas in one tool
      to assumptions in other to combine these results. The correctness
      of the translation is proven in <span class="citation"
      data-cites="sapicplus">(Cheval et al. 2022)</span>.</p>
      <p>The <code>-m</code> flag selects an output module:</p>
      <pre><code> -m --output-module[=spthy|spthytyped|msr|proverif|deepsec]</code></pre>
      <p>The following outputs are supported:</p>
      <ul>
      <li><em>spthy:</em> parse .spthy file and output</li>
      <li><em>spthytyped</em> - parse and type .spthy file ad
      output</li>
      <li><em>msr</em> - parse and type .spthy file and translate
      processes to multiset-rewrite rules</li>
      <li><em>proverif</em>: - translate to <a
      href="https://bblanche.gitlabpages.inria.fr/proverif/">ProVerif</a>
      input format</li>
      <li><em>deepsec</em>: - translate to <a
      href="https://deepsec-prover.github.io/">Deepsec</a> input
      format</li>
      </ul>
      <h2 id="lemma-selection">Lemma selection</h2>
      <p>The same spthy file may be used with multiple tools as backend.
      To list the tools that a lemma should be exported to, use the
      <code>output</code> attribute:</p>
      <pre><code>lemma secrecy[reuse, output=[proverif,msr]]:</code></pre>
      <p>Lemmas are omitted when the currently selected output module is
      not in that list.</p>
      <h2 id="exporting-queries">Exporting queries</h2>
      <p>Security properties are automatically translated, if it is
      possible. (ProVerif only supports two quantifier alternations, for
      example.) As, e.g., DeepSec, supports queries that are not
      expressible in Tamarin’s language, it is possible to define blocks
      that are covered on export. They are written as:</p>
      <pre><code>export IDENTIFIER:
&quot;
    text to export
&quot;</code></pre>
      <p>where IDENTIFIER is one of the following:</p>
      <ul>
      <li><p><code>requests</code>: is included in the requests the
      target solver tries to prove. E.g.:</p>
      <pre><code>export requests:
&quot;
let sys1 = new sk; (!^3 (new skP; P(sk,skP)) | !^3 S(sk)).

let sys2 = new sk; ( ( new skP; !^3 P(sk,skP)) | !^3 S(sk)).

query session_equiv(sys1,sys2).
&quot;</code></pre></li>
      </ul>
      <h2 id="smart-export-features">Smart export features</h2>
      <ul>
      <li>Some predicates / conditions appear in <code>if ..</code>
      processes have <a
      href="007_property-specification.html#sec:predicates-special">dedicates
      translations</a>.</li>
      </ul>
      <h2 id="natural-numbers">Natural numbers</h2>
      <p>SAPIC supports the usage of the builtin natural numbers of both
      GSVerif and Tamarin.</p>
      <p>To use them, variables must be declared with the
      <code>nat</code> type, and the corresponding builtin must be
      declared:</p>
      <pre><code>builtins: natural-numbers

process:

in(ctr0:nat);
let ctr1:nat = ctr0 %+ %1 in
out(ctr1)</code></pre>
      <p>The subterm operator <code>&lt;&lt;</code> will be translated
      for GSVerif as <code>&lt;</code>.</p>
      <p>Beware, declaring a nat variable in SAPIC does not instantiate
      a nat Tamarin variable, which may create additional possible
      sources. To declare and use a true Tamarin nat variable, similar
      to fresh variables and other, each occurence of the variable must
      be prefixed with <code>%</code> (or <code>~</code> in the case of
      fresh variables):</p>
      <pre><code>builtins: natural-numbers

process:

in(%ctr0:nat);
let ctr1:nat = %ctr0 %+ %1 in
out(ctr1)</code></pre>
      <p>This may however lead to divergence in Tamarin and Proverif
      threat models.</p>
      <h2 id="options">Options</h2>
      <p>Some options allow altering the behaviour of the translation,
      but can leat to divergence between Tamarin and Proverif. They
      should be used with care. Adding an option is performed in the
      headers of the file, with:</p>
      <pre><code>options: opt1, opt2, ...</code></pre>
      <p>The available options are:</p>
      <ul>
      <li><code>translation-state-optimisation</code>: this enables the
      pure state translation described in the SAPIC+ paper. Both the
      original and the optimized version do not always yield the same
      benefit, hence the optional switch.</li>
      <li><code>translation-compress-events</code>: by default, each
      event is translated in a singular rule. This may create a Tamarin
      slowdown when translating a sequence of events, but is due to the
      fact that in Proverif, multiple events always occur at distinct
      timestampe. This option allows compressing events into a single
      rule.</li>
      <li><code>translation-progress</code>: see above.</li>
      </ul>
      <div id="refs" class="references csl-bib-body hanging-indent"
      data-entry-spacing="0" role="list">
      <div id="ref-AF-popl01" class="csl-entry" role="listitem">
      Abadi, Martín, and Cédric Fournet. 2001. <span>“Mobile Values, New
      Names, and Secure Communication.”</span> In <em>POPL</em>, 104–15.
      ACM.
      </div>
      <div id="ref-BaDrKr-2016-liveness" class="csl-entry"
      role="listitem">
      Backes, Michael, Jannik Dreier, Steve Kremer, and Robert
      Künnemann. 2017. <span>“A Novel Approach for Reasoning about
      Liveness in Cryptographic Protocols and Its Application to Fair
      Exchange.”</span> In <em>EuroS&amp;p</em>. IEEE Computer Society.
      </div>
      <div id="ref-sapicplus" class="csl-entry" role="listitem">
      Cheval, Vincent, Charlie Jacomme, Steve Kremer, and Robert
      Künnemann. 2022. <span>“<span
      class="math inline">\(\{\)</span>SAPIC+<span
      class="math inline">\(\}\)</span>: Protocol Verifiers of the
      World, Unite!”</span> In <em>31st USENIX Security Symposium
      (USENIX Security 22)</em>, 3935–52.
      </div>
      <div id="ref-jacomme2017symbolic" class="csl-entry"
      role="listitem">
      Jacomme, Charlie, Steve Kremer, and Guillaume Scerri. 2017.
      <span>“Symbolic Models for Isolated Execution
      Environments.”</span> In <em>IEEE European Symposium on Security
      and Privacy (EuroS&amp;p 2017)</em>, 530–45. IEEE.
      </div>
      <div id="ref-KK-jcs16" class="csl-entry" role="listitem">
      Kremer, Steve, and Robert Künnemann. 2016. <span>“Automated
      Analysis of Security Protocols with Global State.”</span>
      <em>Journal of Computer Security</em> 24 (5): 583–616. <a
      href="https://doi.org/10.3233/JCS-160556">https://doi.org/10.3233/JCS-160556</a>.
      </div>
      </div>
    </div>
  </div>
</body>

</html>
