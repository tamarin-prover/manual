<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamarin Prover Manual</title>
  <link rel="stylesheet" type="text/css" href="book.css">
  <script src="book.js"></script>
  <link rel="stylesheet" href="styles/github.css">
  <!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
    <script
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
  </head>

<body class="tamarindoc">
  <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
      <span class="sr-only">Toggle navigation</span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
    <ul class='chapter'>
      <!-- <li><a href='000_prelims.html'><b>0. </b>Preliminaries</a></li> -->
      <li><a href='001_introduction.html'><b>1. </b> Introduction</a></li>
      <li><a href='002_installation.html'><b>2. </b> Installation</a></li>
      <li><a href='003_example.html'><b>3. </b> First Example</a></li>
      <li><a href='004_cryptographic-messages.html'><b>4. </b> Cryptographic Messages</a></li>
      <li><a href='005_protocol-specification-rules.html'><b>5. </b> Protocol Specification using Rules</a></li>
      <li><a href='006_protocol-specification-processes.html'><b>6. </b> Protocol Specification using Processes</a></li>
      <li><a href='007_property-specification.html'><b>7. </b> Property Specification</a></li>
      <li><a href='008_accountability.html'><b>8. </b> Accountability</a></li>
      <li><a href='009_precomputation.html'><b>9. </b> Precomputation</a></li>
      <li><a href='010_modeling-issues.html'><b>10. </b> Modeling Issues</a></li>
      <li><a href='011_advanced-features.html'><b>11. </b> Advanced Features</a></li>
      <li><a href='012_case-studies.html'><b>12.</b> Case Studies</a></li>
      <li><a href='013_toolchains.html'><b>13.</b> Toolchains</a></li>
      <li><a href='014_limitations.html'><b>14.</b> Limitations</a></li>
      <li><a href='015_contact-and-further-reading.html'><b>15.</b> Contact Information and Further Reading</a></li>
      <li><a href='016_syntax_description.html'><b>16.</b> Syntax Description</a></li>
    </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
      <p class="halfbreak">
      </p>
      <h1 id="sec:accountability">Accountability</h1>
      <p>In this section, we give a high-level overview of the
      accountability framework first proposed by <span class="citation"
      data-cites="kunnemann2019">Künnemann, Esiyok, and Backes
      (2019)</span> and revised by <span class="citation"
      data-cites="morio2021">Morio and Künnemann (2021)</span> that is
      implemented in Tamarin.</p>
      <h2 id="sec:accountability-nutshell">Accountability in a
      Nutshell</h2>
      <p>The accountability definition of <span class="citation"
      data-cites="kunnemann2019">Künnemann, Esiyok, and Backes
      (2019)</span> holds parties of a protocol accountable for
      violations of a security property expressed by a trace property
      <span class="math inline">\(φ\)</span>. If a violation occurred,
      at least one party must have deviated from the protocol. Each
      party is either <em>honest</em> and follows the protocol or
      <em>dishonest</em> and may deviate. An honest party <span
      class="math inline">\(A\)</span> becomes dishonest when the event
      <code>Corrupted(A)</code> occurs in the trace and stays dishonest
      for the rest of the protocol execution. A dishonest party does not
      have to deviate and may behave in a way that is indistinguishable
      from its intended behavior.</p>
      <p>The accountability definition focus on parties that are the
      actual cause of a violation. This requires protocols to be defined
      in such a way that deviating parties leave publicly observable
      evidence for security violations. In this sense, a protocol
      provides accountability with respect to a security property <span
      class="math inline">\(φ\)</span> if we can determine all parties
      for which the fact that they are deviating at all is a cause for
      the violation of <span class="math inline">\(φ\)</span>. The
      decision of whether all such parties can be detected in a protocol
      is deferred to a <em>verdict function</em>, stating which parties
      should be held accountable, and a set of <em>verification
      conditions</em> providing soundness and completeness: If and only
      if the verification conditions hold with respect to a security
      property <span class="math inline">\(φ\)</span> and verdict
      function <span class="math inline">\(f\)</span>, the verdict
      function provides the protocol with accountability for <span
      class="math inline">\(φ\)</span>.</p>
      <h2 id="sec:spec-acc">Specifying Accountability in Tamarin</h2>
      <p>The verdict function and verification conditions do not have to
      be defined explicitly in Tamarin. Instead, the implementation adds
      two new syntactic constructs to Tamarin—case tests and
      accountability lemmas—which define the verdict function and
      verification conditions implicitly.</p>
      <p>Let us first lay down an example protocol to which we can come
      back to demonstrate the process of specifying and verifying
      accountability in Tamarin.</p>
      <h3 id="sec:example-1">Running Example</h3>
      <p>We consider a scenario in which access to a central user
      database is logged. There are two types of parties involved:
      managers and employees. Managers can directly access the database,
      while an employee needs to be supported by another employee to
      gain access.</p>
      <p>We are interested in holding parties accountable for the case
      where user data is leaked by either managers or employees. We
      model this protocol using <a
      href="#sec:model-specification">multiset-rewrite rules</a>.</p>
      <p>The database is abstracted by using a fresh variable for the
      user data.</p>
      <pre><code>rule Database:
    [ Fr(~userData) ]
  --[ Database(~userData) ]-&gt;
    [ !DB(~userData) ]</code></pre>
      <p>The party identities are represented by public variables. To
      know if a party is a manager or an employee, they need to be
      registered. We use a restriction action to ensure that the type of
      a party (manager or employee) is distinct.</p>
      <pre><code>rule RegisterManager:
    [ In($x) ]
  --[ IsManager($x)
    , _restrict( not Ex #i. IsEmployee($x)@i ) ]-&gt;
    [ !Manager($x) ]

rule RegisterEmployee:
    [ In($x) ]
  --[ IsEmployee($x)
    , _restrict( not Ex #i. IsManager($x)@i ) ]-&gt;
    [ !Employee($x) ]</code></pre>
      <p>A manager can access and leak the user data in the database on
      its own. Note that the manager leaking the data has to be
      corrupted since leaking data is not their normative behavior.</p>
      <pre><code>rule ManagerLeak:
    [ !Manager($x)
    , !DB(~userData) ]
  --[ LeakManager($x, ~userData)
    , LeakData(~userData)
    , Corrupted($x) ]-&gt;
    [ Out(~userData) ]</code></pre>
      <p>Similarly, two employees can access and leak the user data.
      Again both employees need to be corrupted and they must be
      distinct entities.</p>
      <pre><code>rule EmployeesLeak:
   [ !Employee($x)
   , !Employee($y)
   , !DB(~userData) ]
 --[ LeakEmployees($x, $y, ~userData)
   , LeakData(~userData)
   , Corrupted($x)
   , Corrupted($y)
   , _restrict( not ($x = $y) ) ]-&gt;
   [ Out(~userData) ]</code></pre>
      <p><strong>Remark:</strong> The protocol allows an unbounded
      number of participants for each of the two roles and an unbounded
      number of (concurrent) sessions. With the example setup, we
      continue by explaining case tests.</p>
      <h3 id="sec:case-tests">Case Tests</h3>
      <p>Case tests are named (trace
      properties)[#sec:property_specification] with free variables. Each
      free variable is instantiated with a party that should be blamed
      for a violation.</p>
      <p>Case tests take the form of</p>
      <pre><code>test ⟨name⟩:
  &quot;⟨formula⟩&quot;</code></pre>
      <p>where <code>⟨name⟩</code> is the name of the case test and
      “⟨formula⟩” its formula. A case test ought to have at least one
      free variable and there should be at least one trace where it
      applies.</p>
      <p>In our example, we are interested in holding managers solely
      and employees jointly accountable for leaks. Hence, we define two
      case tests, one for each role:</p>
      <pre><code>test leak_manager:
  &quot;Ex data #i. LeakManager(m, data)@i&quot;

test leak_employees:
  &quot;Ex data #i. LeakEmployees(x, y, data)@i&quot;</code></pre>
      <p>Note that the identifiers of the manager (<code>m</code>) and
      employees (<code>x</code>, <code>y</code>) are free. Intuitively,
      a case test may be seen as a specific manifestation or kind of a
      security violation.</p>
      <p>In the following, we may say that a case test <em>matches</em>
      a trace if there exists some instantiation of the free variables
      of the case test, such that the formula holds on the trace.
      Moreover, we may say that a case test is <em>single-matching</em>
      if it is the only case test matching a trace and there exists only
      one possible instantiation.</p>
      <h2 id="sec:accountability-lemmas">Accountability Lemmas</h2>
      <p>Accountability lemmas are specified similarly to standard
      lemmas:</p>
      <pre><code>lemma ⟨name⟩:
  ⟨name₁⟩,...,⟨nameₙ⟩ account(s) for &quot;⟨formula⟩&quot;</code></pre>
      <p>where <code>⟨name⟩</code> is the name of the lemma,
      <code>⟨name₁⟩</code> to <code>⟨nameₙ⟩</code> are the names of
      previously defined case tests, and <code>⟨formula⟩</code> is the
      security property.</p>
      <p>Coming back to our example, we can state the accountability
      lemma holding parties accountable for leaking the user data:</p>
      <pre><code>lemma acc:
  leak_manager, leak_employees account for
    &quot;All data #i. Database(data)@i ==&gt; not Ex #j. LeakData(data)@j&quot;</code></pre>
      <p>The complete example can be found <a
      href="../code/userdata-leak.spthy">here</a>.</p>
      <p>Each accountability lemma is translated to a set of <span
      class="math inline">\((6n + 1)\)</span> standard lemmas where
      <span class="math inline">\(n\)</span> is the number of case tests
      in the lemma. Each generated lemma corresponds to a verification
      condition in the accountability framework of <span
      class="citation" data-cites="morio2021">(Morio and Künnemann
      2021)</span>.</p>
      <p>When loading our example in Tamarin, the accountability lemma
      <code>acc</code> is translated into the following 13 regular
      lemmas:</p>
      <pre><code>acc_leak_manager_suff (exists-trace)
acc_leak_employees_suff (exists-trace)
acc_verif_empty (all-traces)
acc_leak_manager_verif_nonempty (all-traces)
acc_leak_employees_verif_nonempty (all-traces)
acc_leak_manager_min (all-traces)
acc_leak_employees_min (all-traces)
acc_leak_manager_uniq (all-traces)
acc_leak_employees_uniq (all-traces)
acc_leak_manager_inj (all-traces)
acc_leak_employees_inj (all-traces)
acc_leak_manager_single (exists-trace)
acc_leak_employees_single (exists-trace)</code></pre>
      <p>The naming of the lemmas follows the pattern
      <code>[acc. lemma name]_[case test name]_[condition]</code>, where
      <code>condition</code> is one of <code>suff</code>,
      <code>verif_empty</code>, <code>verif_nonempty</code>,
      <code>min</code>, <code>uniq</code>, <code>inj</code>, and
      <code>single</code>.</p>
      <p>Let us now get a better intuition for the lemmas. We limit
      ourselves to the lemmas of the case test
      <code>leak_employees</code> as well the lemma
      <code>acc_verif_empty</code> which is only generated per
      accountability lemma. Intuition for the remaining lemmas is
      obtained by simply switching the roles of managers and employees
      in the above explanations.</p>
      <dl>
      <dt><code>acc_leak_employees_suff</code></dt>
      <dd>
      <p>This lemma ensures the existence of a trace in which exactly
      one pair of employees and no manager leak the data. Moreover, only
      the two employees may be corrupted in the trace.</p>
      </dd>
      <dt><code>acc_verif_empty</code></dt>
      <dd>
      <p>If neither a manager nor employees leak data, no data is
      leaked.</p>
      </dd>
      <dt><code>acc_leak_employees_verif_nonempty</code></dt>
      <dd>
      <p>If a pair of employees leak data, data is leaked.</p>
      </dd>
      <dt><code>acc_leak_employees_min</code></dt>
      <dd>
      <p>If a pair of employees leak data, there does not exist a prober
      subset of them that also leads to a leak.</p>
      </dd>
      <dt><code>acc_leak_employees_uniq</code></dt>
      <dd>
      <p>If a pair of employees leak data, both of them are
      corrupted.</p>
      </dd>
      <dt><code>acc_leak_employees_inj</code></dt>
      <dd>
      <p>The free variables in <code>leak_employees</code> are
      instantiated with distinct values. In this case, this means that
      the employees are distinct which is ensured by the restriction in
      the rule <code>EmployeesLeak</code>.</p>
      </dd>
      <dt><code>acc_leak_employees_single</code></dt>
      <dd>
      <p>This is a simpler version of
      <code>'acc_leak_employees_suff</code> where no requirements on the
      corrupted parties are made.</p>
      </dd>
      </dl>
      <h2 id="sec:verification-accountability">Verification of
      Accountability Lemmas</h2>
      <p>The generated lemmas can be verified by Tamarin as any other
      lemma. An accountability lemma is said to hold for a theory if
      Tamarin can successfully verify all generated lemmas and the
      so-called <a href="#sec:replacement-property">replacement
      property</a> holds.</p>
      <p>Coming back to our example, we can tell Tamarin to verify the
      lemmas by executing</p>
      <pre><code>tamarin-prover --prove userdata-leak.spthy</code></pre>
      <p>and get the desired result:</p>
      <pre><code>acc_leak_manager_suff (exists-trace): verified (4 steps)
acc_leak_employees_suff (exists-trace): verified (5 steps)
acc_verif_empty (all-traces): verified (4 steps)
acc_leak_manager_verif_nonempty (all-traces): verified (4 steps)
acc_leak_employees_verif_nonempty (all-traces): verified (5 steps)
acc_leak_manager_min (all-traces): verified (4 steps)
acc_leak_employees_min (all-traces): verified (20 steps)
acc_leak_manager_uniq (all-traces): verified (2 steps)
acc_leak_employees_uniq (all-traces): verified (4 steps)
acc_leak_manager_inj (all-traces): verified (1 steps)
acc_leak_employees_inj (all-traces): verified (4 steps)
acc_leak_manager_single (exists-trace): verified (4 steps)
acc_leak_employees_single (exists-trace): verified (5 steps)</code></pre>
      <p>If we are not so lucky and a lemma is falsified, the
      originating accountability lemma may still hold. The following
      list can help us to better understand the consequences of a
      falsified lemma and gives us a hint on how we could solve the
      problem. Let <code>ct</code> be an arbitrary case test. We leave
      out the name of the accountability lemma.</p>
      <h4 id="ct_suff-falsified"><code>_ct_suff</code> falsified</h4>
      <p>There does not exist a single-matched trace for <code>ct</code>
      in which only a subset of the blamed parties is corrupted. At
      least one party, which is needed to cause a violation, is not
      blamed. <em>Accountability may still be provided.</em></p>
      <p><strong>Hint:</strong> We assume that
      <code>_ct_verif_nonempty</code> is verified. If
      <code>_ct_single</code> is also falsified, then we should solve
      this problem first. Otherwise, there exists at least one corrupted
      party in all single-matched traces of <code>ct</code>, which is
      not one of the instantiated free variables of <code>ct</code>. It
      may be possible to revise <code>ct</code> by adding additional
      free variables and action constraints such that all parties needed
      for a violation are blamed by <code>ct</code>.</p>
      <h4 id="verif_empty-falsified"><code>_verif_empty</code>
      falsified</h4>
      <p>The security property is violated but no case test matches.
      This indicates that the case tests are not exhaustive, that is,
      capture all possible ways to cause a violation. <em>Accountability
      is not provided.</em></p>
      <p><strong>Hint:</strong> The trace found by Tamarin as a
      counterexample may give a clue for an additional case test or
      shows that the security property can be violated in an unintended
      way.</p>
      <h4
      id="ct_verif_nonempty-falsified"><code>_ct_verif_nonempty</code>
      falsified</h4>
      <p>The case test <code>ct</code> matches but the security property
      is not violated. This indicates that there exists a trace where
      the parties blamed by <code>ct</code> are not sufficient to cause
      a violation. <em>Accountability is not provided.</em></p>
      <p><strong>Hint:</strong> The trace found by Tamarin as a
      counterexample may give a clue for revising <code>ct</code> such
      that for all traces in which it matches, the security property is
      violated.</p>
      <h4 id="ct_min-falsified"><code>_ct_min</code> falsified</h4>
      <p>There exists an instantiation of a case test <code>cs</code> in
      which strictly fewer parties than in an instantiation of
      <code>ct</code> in the same trace are blamed. <em>Accountability
      is not provided.</em></p>
      <p><strong>Hint:</strong> We assume that
      <code>_ct_verif_nonempty</code> and
      <code>_cs_verif_nonempty</code> are verified. If both
      <code>ct</code> and <code>cs</code> are necessary for
      <code>_verif_empty</code> to be verified, they need to be
      separated such that they do not match simultaneously. This can be
      accomplished by replacing <code>ct</code> with
      <code>ct ∧ ¬(cs ∧ fv(cs) ⊊ fv(ct))</code> where <code>fv(c)</code>
      denotes the free variables of case test <code>c</code>.</p>
      <h4 id="ct_uniq-falsified"><code>_ct_uniq</code> falsified</h4>
      <p>A party is blamed by an instantiation of <code>ct</code> but it
      has not been corrupted, thereby holding an honest party
      accountable. <em>Accountability is not provided.</em></p>
      <p><strong>Hint:</strong> We assume
      <code>_ct_verif_nonempty</code> is verified. If
      <code>_ct_min</code> is also falsified, we should solve this
      problem first. The trace found by Tamarin as a counterexample
      shows which party is blamed unwarranted. If the corresponding
      instantiated free variable can never be corrupted, it can be
      quantified in <code>ct</code> to avoid being blamed. If it can be
      corrupted for some traces, a closer look on <code>ct</code> and
      the protocol is necessary.</p>
      <h4 id="ct_single-falsified"><code>_ct_single</code>
      falsified</h4>
      <p>There does not exist a single-matched trace for
      <code>ct</code>. Either</p>
      <ol type="1">
      <li>there does not exist a trace where <code>ct</code> matches,
      or</li>
      <li><code>ct</code> always matches with multiple instantiations
      simultaneously, or</li>
      <li>for all traces there exists another case test which matches at
      the time. <em>Accountability may still be provided.</em></li>
      </ol>
      <p><strong>Hint:</strong> We assume
      <code>_ct_verif_nonempty</code> is verified. In case 1,
      <code>ct</code> may be ill-defined or contains a logic error. In
      case 2, if all the instantiations are permutations of each other,
      a single-matched trace may be obtained by making <code>ct</code>
      antisymmetric. This ensures that whenever the instantiated free
      variables of two instantiations are the same, then the
      instantiations are equivalent. If the instantiations are not
      permutations, at least two disjoint groups of parties are always
      blamed. This requires a closer look on <code>ct</code> and the
      protocol. In case 3, it may be possible to merge multiple case
      tests together for which then a single-matched trace exists.</p>
      <h4 id="ct_inj-falsified"><code>_ct_inj</code> falsified</h4>
      <p>The case test <code>ct</code> is not injective. There exists an
      instantiation mapping distinct free variables to the same party.
      <em>Accountability may still be provided.</em></p>
      <p><strong>Hint:</strong> <code>ct</code> can be split into
      multiple case tests for which <code>_inj</code> holds. Assume that
      <code>fv(ct) = {x, y, z}</code> and all free variables coincide in
      any combination. These are given by the partitions of the free
      variables:</p>
      <ul>
      <li><code>{{x, y, z}}</code></li>
      <li><code>{{x}, {y, z}}</code></li>
      <li><code>{{y}, {x, z}}</code></li>
      <li><code>{{z}, {x, y}}</code></li>
      <li><code>{{x}, {y}, {z}}</code></li>
      </ul>
      <p>We then need to split <code>ct</code> into five case tests in
      which the variables in each group are replaced by a single
      variable. For example, in the second case above, we replace each
      occurrence of <code>y</code> and <code>z</code> by a new variable
      <code>v</code>.</p>
      <p>Note that for the conditions <code>_ct_suff</code>,
      <code>_ct_min</code>, and <code>_ct_single</code> we assumed above
      that the case tests satisfy <code>_ct_verif_nonempty</code>. If
      this is not the case, then the case test has a fatal error—it does
      not always lead to a violation—which renders the other conditions
      meaningless</p>
      <p>In summary, the consequences of falsified lemmas are shown in
      the following table, where a ✗ indicates that accountability is
      not provided and a (✓) that accountability may still be
      provided.</p>
      <table>
      <thead>
      <tr>
      <th>Falsified lemma</th>
      <th style="text-align: center;">Accountability provided</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td><code>_ct_suff</code></td>
      <td style="text-align: center;">(✓)</td>
      </tr>
      <tr>
      <td><code>_verif_empty</code></td>
      <td style="text-align: center;">✗</td>
      </tr>
      <tr>
      <td><code>_ct_verif_nonempty</code></td>
      <td style="text-align: center;">✗</td>
      </tr>
      <tr>
      <td><code>_ct_min</code></td>
      <td style="text-align: center;">✗</td>
      </tr>
      <tr>
      <td><code>_ct_uniq</code></td>
      <td style="text-align: center;">✗</td>
      </tr>
      <tr>
      <td><code>_ct_single</code></td>
      <td style="text-align: center;">(✓)</td>
      </tr>
      <tr>
      <td><code>_ct_inj</code></td>
      <td style="text-align: center;">(✓)</td>
      </tr>
      </tbody>
      </table>
      <h2 id="sec:replacement-property">Replacement Property</h2>
      <p>The replacement property (RP) is used to ensure that there is a
      decomposition of each trace that separates interleaving causally
      relevant events so they can be regarded in isolation. Intuitively,
      RP says that when we have a single-matched trace for a case test
      (ensured by ’_single`), then we can replace its parties by any
      other parties allowed by the theory.</p>
      <p>Let us consider an example to better understand what this means
      in practice.</p>
      <pre><code>test A:
  &quot;Ex #i. A(x, y)@i

test B:
  &quot;Ex #i. B(x, y)@i</code></pre>
      <p>We have two case tests <code>A</code> and <code>B</code> each
      blaming the two parties (free variables) <code>x</code> and
      <code>y</code>. Assume that there exist the following traces in
      our theory:</p>
      <pre><code>t1 = A(&#39;S&#39;, &#39;T&#39;); B(&#39;S&#39;, &#39;T&#39;)
t2 = B(&#39;C&#39;, &#39;D&#39;)</code></pre>
      <p>In <code>t1</code> both case test <code>A</code> and
      <code>B</code> match with the instantiation
      <code>[x → 'S', y → 'T]</code>. In <code>t2</code> only case test
      ‘B’ matches with the instantiation
      <code>[x → 'C', y → 'D']</code>. The replacement property now
      requires that there exists a trace <code>t3</code> in which only
      case test <code>B</code> matches with its instantiation from
      <code>t1</code>:</p>
      <pre><code>t3 = B(&#39;S&#39;, &#39;T&#39;)</code></pre>
      <p>In fact, we replaced the parties of <code>B</code> in
      <code>t2</code> with the parties of <code>B</code> in
      <code>t1</code>. Observe that this is the reason why the
      <code>_inj</code> lemma is necessary. We can see the replacement
      as first applying the inverse instantiation of the single-matched
      trace (here in <code>t2</code> with
      <code>['C' → x, 'D' → y]) and then applying the instantiation of the other (possibly multi-matched) trace (here in't1</code>
      with <code>[x → 'S', y → 'T]</code>).</p>
      <p>A sufficient criterion implying RP is that traces are closed
      under bijective renaming. The implementation features a coarse
      syntactical check by ensuring that</p>
      <ol type="1">
      <li>the theory includes no restriction,</li>
      <li>the theory uses no public names, and</li>
      <li>the free variables of case tests can only be instantiated by
      public variables.</li>
      </ol>
      <p>If any of these conditions is not satisfied, a wellformedness
      warning is shown stating that RP has to be checked manually.</p>
      <p>Note that in our example, when executing Tamarin to verify the
      lemmas, we get such a warning:</p>
      <pre><code>The specification contains at least one restriction.</code></pre>
      <p>Hence, we need to ensure that the restrictions do not limit our
      ability to rename parties. Our theory contains three restrictions.
      Two for ensuring that managers and employees are distinct and one
      for ensuring that an employee cannot take a double role when
      leaking data:</p>
      <pre><code>restriction Restr_RegisterManager_1:
  &quot;∀ x #NOW.
    (Restr_RegisterManager_1( x ) @ #NOW) ⇒ (¬(∃ #i. IsEmployee( x ) @ #i))&quot;

restriction Restr_RegisterEmployee_1:
  &quot;∀ x #NOW.
    (Restr_RegisterEmployee_1( x ) @ #NOW) ⇒ (¬(∃ #i. IsManager( x ) @ #i))&quot;

restriction Restr_EmployeeLeak_1:
  &quot;∀ x #NOW x.1. (Restr_EmployeeLeak_1( x, x.1 ) @ #NOW) ⇒ (¬(x = x.1))&quot;</code></pre>
      <p>In the first two cases, if we have a single-matched trace where
      some manager or employee registers and their role is distinct,
      then that is also the case when we rename the party in any
      conceivable way. There is no possibility of a role to lose their
      distinctiveness due to the absence of public names. In the third
      case, when two employees are distinct in one trace, they remain
      distinct after bijective renaming. So in our example, the
      restrictions are unproblematic for RP and our verification result
      is valid.</p>
      <h2 id="references">References</h2>
      <div id="refs" class="references csl-bib-body hanging-indent"
      data-entry-spacing="0" role="list">
      <div id="ref-kunnemann2019" class="csl-entry" role="listitem">
      Künnemann, Robert, Ilkan Esiyok, and Michael Backes. 2019.
      <span>“Automated <span>Verification</span> of
      <span>Accountability</span> in <span>Security
      Protocols</span>.”</span> In <em>2019 <span>IEEE</span> 32nd
      <span>Computer Security Foundations Symposium</span>
      (<span>CSF</span>)</em>, 397–39716. <a
      href="https://doi.org/10.1109/CSF.2019.00034">https://doi.org/10.1109/CSF.2019.00034</a>.
      </div>
      <div id="ref-morio2021" class="csl-entry" role="listitem">
      Morio, Kevin, and Robert Künnemann. 2021. <span>“Verifying
      Accountability for Unbounded Sets of Participants.”</span> In
      <em>34th <span>IEEE</span> Computer Security Foundations
      Symposium, <span>CSF</span> 2021, Dubrovnik, Croatia, June 21-25,
      2021</em>, 1–16. <span>IEEE</span>. <a
      href="https://doi.org/10.1109/CSF51468.2021.00032">https://doi.org/10.1109/CSF51468.2021.00032</a>.
      </div>
      </div>
    </div>
  </div>
</body>

</html>
