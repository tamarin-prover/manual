<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamarin Prover Manual</title>
  <link rel="stylesheet" type="text/css" href="book.css">
  <script src="book.js"></script>
  <link rel="stylesheet" href="styles/github.css">
  <!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
  </head>

<body class="tamarindoc">
  <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
      <span class="sr-only">Toggle navigation</span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
    <ul class='chapter'>
      <!-- <li><a href='000_prelims.html'><b>0. </b>Preliminaries</a></li> -->
      <li><a href='001_introduction.html'><b>1. </b> Introduction</a></li>
      <li><a href='002_installation.html'><b>2. </b> Installation</a></li>
      <li><a href='003_example.html'><b>3. </b> First Example</a></li>
      <li><a href='004_cryptographic-messages.html'><b>4. </b> Cryptographic Messages</a></li>
      <li><a href='005_protocol-specification-rules.html'><b>5. </b> Protocol Specification using Rules</a></li>
      <li><a href='006_protocol-specification-processes.html'><b>6. </b> Protocol Specification using Processes</a></li>
      <li><a href='007_property-specification.html'><b>7. </b> Property Specification</a></li>
      <li><a href='008_accountability.html'><b>8. </b> Accountability</a></li>
      <li><a href='009_precomputation.html'><b>9. </b> Precomputation</a></li>
      <li><a href='010_modeling-issues.html'><b>10. </b> Modeling Issues</a></li>
      <li><a href='011_advanced-features.html'><b>11. </b> Advanced Features</a></li>
      <li><a href='012_case-studies.html'><b>12.</b> Case Studies</a></li>
      <li><a href='013_toolchains.html'><b>13.</b> Toolchains</a></li>
      <li><a href='014_limitations.html'><b>14.</b> Limitations</a></li>
      <li><a href='015_contact-and-further-reading.html'><b>15.</b> Contact Information and Further Reading</a></li>
      <li><a href='016_syntax_description.html'><b>16.</b> Syntax Description</a></li>
    </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
      <p class="halfbreak">
      </p>
      <h1 id="sec:advanced-features">Advanced Features</h1>
      <p>We now turn to some of Tamarin’s more advanced features. We
      cover custom heuristics, the GUI, channel models, induction,
      internal preprocessor, and how to measure the time needed for
      proofs. <!--manual proofs,encoding tricks,--></p>
      <h2 id="sec:heuristics">Heuristics</h2>
      <p>A heuristic describes a method to rank the open goals of a
      constraint system and is specified as a sequence of goal rankings.
      Each goal ranking is abbreviated by a single character from the
      set <code>{s,S,c,C,i,I,o,O}</code>.</p>
      <p>A global heuristic for a protocol file can be defined using the
      <code>heuristic:</code> statement followed by the sequence of goal
      rankings. The heuristic which is used for a particular lemma can
      be overwritten using the <code>heuristic</code> lemma attribute.
      Finally, the heuristic can be specified using the
      <code>--heuristic</code> command line option.</p>
      <p>The precedence of heuristics is:</p>
      <ol type="1">
      <li>Command line option (<code>--heuristic</code>)</li>
      <li>Lemma attribute (<code>heuristic=</code>)</li>
      <li>Global (<code>heuristic:</code>)</li>
      <li>Default (<code>s</code>)</li>
      </ol>
      <p>The goal rankings are as follows.</p>
      <dl>
      <dt><code>s</code>:</dt>
      <dd>
      the ‘smart’ ranking is the ranking described in the extended
      version of our CSF’12 paper. It is the default ranking and works
      very well in a wide range of situations. Roughly, this ranking
      prioritizes chain goals, disjunctions, facts, actions, and
      adversary knowledge of private and fresh terms in that order
      (e.g., every action will be solved before any knowledge goal).
      Goals marked ‘Probably Constructable’ and ‘Currently Deducible’ in
      the GUI are lower priority.
      </dd>
      <dt><code>S</code>:</dt>
      <dd>
      is like the ‘smart’ ranking, but does not delay the solving of
      premises marked as loop-breakers. What premises are loop breakers
      is determined from the protocol using a simple under-approximation
      to the vertex feedback set of the conclusion-may-unify-to-premise
      graph. We require these loop-breakers for example to guarantee the
      termination of the case distinction precomputation. You can
      inspect which premises are marked as loop breakers in the
      ‘Multiset rewriting rules’ page in the GUI.
      </dd>
      <dt><code>c</code>:</dt>
      <dd>
      is the ‘consecutive’ or ‘conservative’ ranking. It solves goals in
      the order they occur in the constraint system. This guarantees
      that no goal is delayed indefinitely, but often leads to large
      proofs because some of the early goals are not worth solving.
      </dd>
      <dt><code>C</code>:</dt>
      <dd>
      is like ‘c’ but without delaying loop breakers.
      </dd>
      <dt><code>i</code>:</dt>
      <dd>
      is a ranking developed to be well-suited to injective stateful
      protocols. The priority of goals is similar to the ‘S’ ranking,
      but instead of a strict priority hierarchy, the fact, action, and
      knowledge goals are considered equal priority and solved by their
      age. This is useful for stateful protocols with an unbounded
      number of runs, in which for example solving a fact goal may
      create a new fact goal for the previous protocol run. This ranking
      will prioritize existing fact, action, and knowledge goals before
      following up on the fact goal of that previous run. In contrast
      the ‘S’ ranking would prioritize this new fact goal ahead of any
      existing action or knowledge goal, although solving the new goal
      may create yet another earlier fact goal and so on, preventing
      termination.
      </dd>
      <dt><code>I</code>:</dt>
      <dd>
      is like ‘i’ but without delaying loop breakers.
      </dd>
      <dt><code>{.}</code>:</dt>
      <dd>
      is the tactic ranking. It allows the user to provide an arbitrary
      ranking for the proof goals, specified in a language native to
      Tamarin. Each tactic needs to be given a name. For the tactic
      named <code>default</code>, the call would be
      <code>{default}</code>. The syntax of the tactics will be detailed
      below in the part <code>Using a tactic</code>. However, for a
      quick overview, a tactic is composed of several fields. The first
      one, <code>tactic</code>, specifies the name of the tactic and is
      mandatory. Then <code>presort</code> (optional) allows the user to
      choose the based ranking of the input. The keywords
      <code>prio</code> and <code>deprio</code> defines the ranks of the
      goals. They gather functions that will recognize the goals. The
      higher the prio that recognize a goal, the sooner it will be
      treated and the lower the deprio, the later. The user can choose
      to write as much of prio or deprio as needed. A tactic can also be
      composed of only prio or deprio. The functions are preimplemented
      and allow to reach information unavailable from oracle (the state
      of the system or the proof context).
      </dd>
      <dt><code>o</code>:</dt>
      <dd>
      is the oracle ranking. It allows the user to provide an arbitrary
      program that runs independently of Tamarin and ranks the proof
      goals. The path of the program can be specified after the goal
      ranking, e.g., <code>o "oracles/oracle-default"</code> to use the
      program <code>oracles/oracle-default</code> as the oracle. If no
      path is specified, the default is <code>oracle</code>. The path of
      the program is relative to the directory of the protocol file
      containing the goal ranking. If the heuristic is specified using
      the <code>--heuristic</code> option, the path can be given using
      the <code>--oraclename</code> command line option. In this case,
      the path is relative to the current working directory. The
      oracle’s input is a numbered list of proof goals, given in the
      ‘Consecutive’ ranking (as generated by the heuristic
      <code>C</code>). Every line of the input is a new goal and starts
      with “%i:”, where %i is the index of the goal. The oracle’s output
      is expected to be a line-separated list of indices, prioritizing
      the given proof goals. Note that it suffices to output the index
      of a single proof goal, as the first ranked goal will always be
      selected. Moreover, the oracle is also allowed to terminate
      without printing a valid index. In this case, the first goal of
      the ‘Consecutive’ ranking will be selected.
      </dd>
      <dt><code>O</code>:</dt>
      <dd>
      is the oracle ranking based on the ‘smart’ heuristic
      <code>s</code>. It works the same as <code>o</code> but uses
      ‘smart’ instead of ‘Consecutive’ ranking to start with.
      </dd>
      <dt><code>p</code>:</dt>
      <dd>
      is the SAPIC-specific ranking. It is a modified version of the
      smart <code>s</code> heuristic, but resolves SAPIC’s
      <code>state</code>-facts right away, as well as Unlock goals, and
      some helper facts introduced in SAPICs translation
      (<code>MID_Receiver</code>, <code>MID_Sender</code>).
      <code>Progress_To</code> goals (which are generated when using the
      optional <a
      href="006_protocol-specification-processes.html#sec:local-progress">local
      progress</a>) are also prioritised. Similar to <a
      href="#sec:fact-annotations">fact annotations</a> below, this
      ranking also introduces a prioritisation for
      <code>Insert</code>-actions When the first element of the key is
      prefixed <code>F_</code>, the key is prioritized, e.g.,
      <code>lookup &lt;F_key,p&gt; as v in ...</code>. Using
      <code>L_</code> instead of <code>F_</code> achieves
      deprioritsation. Likewise, names and be (de)prioritized by
      prefixes them in the same manner. See <span class="citation"
      data-cites="KK-jcs16">(Kremer and Künnemann 2016)</span> for the
      reasoning behind this ranking.
      </dd>
      <dt><code>P</code>:</dt>
      <dd>
      is like <code>p</code> but without delaying loop breakers.
      </dd>
      </dl>
      <p>If several rankings are given for the heuristic flag, then they
      are employed in a round-robin fashion depending on the
      proof-depth. For example, a flag <code>--heuristic=ssC</code>
      always uses two times the smart ranking and then once the
      ‘Consecutive’ goal ranking. The idea is that you can mix goal
      rankings easily in this way.</p>
      <h2 id="sec:fact-annotations">Fact annotations</h2>
      <p>Facts can be annotated with <code>+</code> or <code>-</code> to
      influence their priority in heuristics. Annotating a fact with
      <code>+</code> causes the tool to solve instances of that fact
      earlier than normal, while annotating a fact with <code>-</code>
      will delay solving those instances. A fact can be annotated by
      suffixing it with the annotation in square brackets. For example,
      a fact <code>F(x)[+]</code> will be prioritized, while a fact
      <code>G(x)[-]</code> will be delayed.</p>
      <p>Fact annotations apply only to the instances that are
      annotated, and are not considered during unification. For example,
      a rule premise containing <code>A(x)[+]</code> can unify with a
      rule conclusion containing <code>A(x)</code>. This allows multiple
      instances of the same fact to be solved with different priorities
      by annotating them differently.</p>
      <p>The <code>+</code> and <code>-</code> annotations can also be
      used to prioritize actions. For example, A reusable lemma of the
      form</p>
      <pre><code>    &quot;All x #i #j. A(x) @ i ==&gt; B(x)[+] @ j&quot;</code></pre>
      <p>will cause the <code>B(x)[+]</code> actions created when
      applying this lemma to be solved with higher priority.</p>
      <p>Heuristic priority can also be influenced by starting a fact
      name with <code>F_</code> (for first) or <code>L_</code> (for
      last) corresponding to the <code>+</code> and <code>-</code>
      annotations respectively. Note however that these prefixes must
      apply to every instance of the fact, as a fact <code>F_A(x)</code>
      cannot unify with a fact <code>A(x)</code>.</p>
      <p>Facts in rule premises can also be annotated with
      <code>no_precomp</code> to prevent the tool from precomputing
      their sources. Use of the <code>no_precomp</code> annotation in
      key places can be very useful for reducing the precomputation time
      required to load large models, however it should be used
      sparingly. Preventing the precomputation of sources for a premise
      that is solved frequently will typically slow down the tool, as it
      must solve the premise each time instead of directly applying
      precomputed sources. Note also that using this annotation may
      cause partial deconstructions if the source of a premise was
      necessary to compute a full deconstruction.</p>
      <p>The <code>no_precomp</code> annotation can be used in
      combination with heuristic annotations by including both separated
      by commas—e.g., a premise <code>A(x)[-,no_precomp]</code> will be
      delayed and also will not have its sources precomputed.</p>
      <h3 id="using-a-tactic-subsec-tactic">Using a Tactic {subsec:
      tactic}</h3>
      <p>The tactics are a language native to Tamarin designed to allow
      user to write custom rankings of proof goals.</p>
      <h4 id="writing-a-tactic">Writing a tactic</h4>
      <p>In order to explain the way a tactic should be written, we will
      use the simple example (theory SourceOfUniqueness). The first step
      is to identify the tactic by giving it a name (here uniqueness).
      Then you can choose a <code>presort</code>. It has the same role
      as the c or C option but with more options. Depending on whether
      you are using the diff mode are not, you will respectively be able
      to choose among ‘s’, ‘S’, ‘c’ and ‘C’ and ‘C’, ‘I’, ‘P’, ‘S’, ‘c’,
      ‘i’, ‘p’, ‘s’. Note that this field is optional and will by
      default be set at <code>s</code>.</p>
      <pre><code>tactic: uniqueness
presort: C</code></pre>
      <p>Then we will start to write the priorities following which we
      want to order the goals. Every priority, announced by the
      <code>prio</code> keywords, is composed of functions that will try
      to recognize characteristics in the goals given by the Tamarin
      proofs. If a goal is recognized by a function in a priority, it
      will be be ranked as such, i.e., the higher the priority in the
      tactic, the higher the goals it recognizes will be ranked. The
      particularity recognized by every function will be detailed in a
      paragraph below. The tactic language authorizes to combine
      functions using <code>|</code>, <code>&amp;</code> and
      <code>not</code>. Even if the option is not necessary for the
      proof of the lemma uniqueness, let’s now explore the
      <code>deprio</code> keyword. It works as the <code>prio</code> one
      but with the opposite goal since it allows the user to put the
      recognized goals at the bottom of the ranking. In case several
      <code>deprio</code> are written, the first one will be ranked
      higher than the last ones. If a goal is recognized by two or more
      ‘priorities’ or ‘depriorities’, only the first one (i.e., the
      higher rank possible) will be taken into account for the final
      ranking. The order of the goals recognized by the same priority is
      usually predetermined by the presort. However, if this order is
      not appropriate for one priority, the user can call a ‘postranking
      function’. This function will reorder the goals inside the
      priority given a criteria. If no postranking function is
      determined, Tamarin will use the identity. For now, the only other
      option is <code>smallest</code>, a function that will order the
      goals by increasing size of their pretty-printed strings.</p>
      <pre><code>prio:
    isFactName &quot;ReceiverKeySimple&quot;
prio:
    regex &quot;senc\(xsimple&quot; | regex &quot;senc\(~xsimple&quot;
prio: {smallest}
    regex &quot;KU\( ~key&quot;
}</code></pre>
      <h4 id="calling-a-tactic">Calling a tactic</h4>
      <p>Like the other heuristics, tactics can be called two ways. The
      first one is using the command line. In the case study above, it
      would be:
      <code>tamarin-prover --prove --heuristic={prove=uniqueness} SourceOfUniqueness.spthy</code>.
      The other way is directly integrated in the file by adding
      <code>[heuristic={uniqueness}]</code> next to the name of the
      lemma that is supposed to use it. The option does not need to be
      called again from the command line. The second option is helpful
      when working with a file containing several tactics used by
      different lemmas.</p>
      <h4 id="ranking-functions">Ranking functions</h4>
      <p>The functions used in the tactic language are implemented in
      Tamarin. Below you can find a list of the currently available
      functions. At the end at this section, you will find an
      explanation on how to write your own functions if the one
      described here do not suffice for your usage.</p>
      <p>Pre-implemented functions * <code>regex</code>: as explain
      above, this function takes in parameter a string and will use it
      as a pattern to match against the goals. (Since it is based on the
      Text.Regex.PCRE module of Haskell, some characters, as the
      parenthesis, will need to be escaped to achieve the desired
      behavior). * <code>isFactName</code>: as is given by its name,
      this function will go look in the Tamarin object ‘goal’ and check
      if the field FactName matches its parameter. To give an example of
      its usage, <code>isFactName</code> could be used instead of
      <code>regex</code> for the first prio of the above example with
      same results. * <code>isInFactTerms</code>: the function will look
      in the list contained in the field FactTest whether an element
      corresponding the parameter can be found. The following functions
      are also implemented but specifically designed to translate the
      oracles of the Vacarme tool into tactics: *
      <code>dhreNoise</code>: recognize goals containing a
      Diffie-Hellman exponentiation. For example, the goal
      <code>Recv( &lt;'g'^~e.1,aead(kdf2(&lt;ck, 'g'^(~e*~e.1)&gt;), '0', h(&lt;hash, 'g'^~e.1&gt;), peer),aead(kdf2(&lt;kdf1(&lt;ck, 'g'^(~e*~e.1)&gt;), z&gt;), '0',h(&lt;h(&lt;hash, 'g'^~e.1&gt;),aead(kdf2(&lt;ck, 'g'^(~e*~e.1)&gt;), '0', h(&lt;hash, 'g'^~e.1&gt;), peer)&gt;), payload)&gt;) ▶₁ #claim</code>
      is recognized thanks to the presence of the following pattern
      <code>'g'^~e.1</code>. The function does need one parameter from
      the user, the type of oracle it is used for. It can be
      <code>def</code> for the Vacarme default case, <code>curve</code>
      for Vacarme oracle_C25519_K1X1 case and <code>diff</code> if the
      tactic is used to prove an equivalence lemma. If the parameter
      specified is anything else, the default case will be used. It
      works as follows. First, it will retrieve from the system state
      the formulas that have the <code>Reveal</code> fact name and
      matches the regex <code>exp\\('g'</code>. For the retrieved
      formulas, it will then put in a list the content of the
      <code>Free</code> variables along the variable <code>~n</code>. In
      the case of the example given above, the list would be
      <code>[~n,~e,~e.1]</code>. They are the variable that the function
      will try to match against. Once it is done, the tested goal will
      be recognized if it includes an exponentiation that uses the
      previously listed elements (just one as exponent or a
      multiplication).<br />
      * <code>defaultNoise</code>: this function takes two parameter:
      the oracle type (as explained for <code>dhreNoise</code>) and a
      regex pattern. The regex pattern should allow the program to
      extract the nonces targeted by the user from the goal. For
      example, in the default case of Vacarme, the regex is
      <code>(?&lt;!'g'\^)\~[a-zA-Z.0-9]*</code> and aims at recovering
      the nonces used in exponentiation. The goal of the function is to
      verify that all the recovered nonces can be found in the list
      extracted from the system state as explained for
      <code>dhreNoise</code>. The goal will only be recognized if all
      his nonces are in the list. * <code>reasonableNoncesNoise</code>:
      takes one parameter (same as <code>dhreNoise</code>). It works as
      <code>defaultNoise</code> but works with all the nonces of the
      goal and therefore does not need a regex pattern to retrieve them.
      * <code>nonAbsurdGoal</code>: this function retrieve the functions
      names present in the goal and verifies if they are “Ku” or “inv”
      (this means the key words coming before parenthesis). It also
      retrieves the list of nonces form the system state as explained
      for <code>dhreNoise</code> and checks if they do not appear in the
      goal. If both the conditions are verified, the goal is recognized.
      It only takes one argument (the same as dhreNoise).</p>
      <h4 id="how-to-write-your-own-functions">How to write your own
      function(s)</h4>
      <p>The functions need to be added to the
      lib/theory/src/Theory/Text/Parser/Tactics.hs file, in the function
      named tacticFunctions. The implementation has been designed to be
      modular. The first step is to record the function in the
      repertory, the name in quote will be the one used by the user in
      the tactic, the other, the one used for the implementation. They
      can be different if necessary. The “user function name” also need
      to be added to the nameToFunction list, along with a quick
      description for the error message. Regarding the implementation of
      the function, the first thing to know is that every function you
      write will take two parameters. The first one is the list of
      strings that the user may pass to the function (the pattern for
      regex for example). Nothing forbids the user to write as many
      parameters as he wants, we will however only use the first ones we
      need. The second parameter is a triplet composed of the goal being
      tested, the proof context and the system. The function then needs
      to return a boolean, <code>True</code> if the goal, proof context
      or system have been recognized, <code>False</code> if not. If
      needed, new postranking functions can be added by doing the
      following steps. First registering the name of the new function in
      the <code>rankingFunctions</code> function in
      lib/theory/src/Theory/Text/Parser/Tactics.hs. Then writing the
      function. It only needs to take in parameters the goals to sort
      and return them in the new order. To be considered, the code then
      needs to be recompiled, using <code>make</code>. The new function
      is then ready to be used.</p>
      <h3 id="using-an-oracle">Using an Oracle</h3>
      <p>Oracles allow to implement user-defined heuristics as custom
      rankings of proof goals. They are invoked as a process with the
      lemma under scrutiny as the first argument and all current proof
      goals seperated by EOL over stdin. Proof goals match the regex
      <code>(\d+):(.+)</code> where <code>(\d+)</code> is the goal’s
      index, and <code>(.+)</code> is the actual goal. A proof goal is
      formatted like one of the applicable proof methods shown in the
      interactive view, but without <strong>solve(…)</strong>
      surrounding it. One can also observe the input to the oracle in
      the stdout of tamarin itself. Oracle calls are logged between
      <code>START INPUT</code>, <code>START OUTPUT</code>, and
      <code>END Oracle call</code>.</p>
      <p>The oracle can set the new order of proof goals by writing the
      proof indices to stdout, separated by EOL. The order of the
      indices determines the new order of proof goals. An oracle does
      not need to rank all goals. Unranked goals will be ranked with
      lower priority than ranked goals but kept in order. For example,
      if an oracle was given the goals 1-4, and would output:</p>
      <pre><code>4
2</code></pre>
      <p>the new ranking would be 4, 2, 1, 3. In particular, this
      implies that an oracle which does not output anything, behaves
      like the identity function on the ranking.</p>
      <p>Next, we present a small example to demonstrate how an oracle
      can be used to generate efficient proofs.</p>
      <p>Assume we want to prove the uniqueness of a pair
      <code>&lt;xcomplicated,xsimple&gt;</code>, where
      <code>xcomplicated</code> is a term that is derived via a
      complicated and long way (not guaranteed to be unique) and
      <code>xsimple</code> is a unique term generated via a very simple
      way. The built-in heuristics cannot easily detect that the
      straightforward way to prove uniqueness is to solve for the term
      <code>xsimple</code>. By providing an oracle, we can generate a
      very short and efficient proof nevertheless.</p>
      <p>Assume the following theory.</p>
      <pre><code>theory SourceOfUniqueness begin

heuristic: o &quot;myoracle&quot;

builtins: symmetric-encryption

rule generatecomplicated:
 [ In(x), Fr(~key)  ]
 --[ Complicated(x) ]-&gt;
 [ Out(senc(x,~key)), ReceiverKeyComplicated(~key) ]

rule generatesimple:
 [ Fr(~xsimple), Fr(~key)  ]
 --[ Simpleunique(~xsimple) ]-&gt;
 [ Out(senc(~xsimple,~key)), ReceiverKeySimple(~key) ]

rule receive:
 [ ReceiverKeyComplicated(keycomplicated), In(senc(xcomplicated,keycomplicated))
 , ReceiverKeySimple(keysimple), In(senc(xsimple,keysimple))
 ]
 --[ Unique(&lt;xcomplicated,xsimple&gt;) ]-&gt;
 [  ]

//this restriction artificially complicates an occurrence of an event Complicated(x)
restriction complicate:
 &quot;All x #i. Complicated(x)@i
   ==&gt; (Ex y #j. Complicated(y)@j &amp; #j &lt; #i) | (Ex y #j. Simpleunique(y)@j &amp; #j &lt; #i)&quot;

lemma uniqueness:
 &quot;All #i #j x. Unique(x)@i &amp; Unique(x)@j ==&gt; #i=#j&quot;

end
</code></pre>
      <p>We use the following oracle to generate an efficient proof.</p>
      <pre><code>#!/usr/bin/env python

from __future__ import print_function
import sys

lines = sys.stdin.readlines()

l1 = []
l2 = []
l3 = []
l4 = []
lemma = sys.argv[1]

for line in lines:
  num = line.split(&#39;:&#39;)[0]

  if lemma == &quot;uniqueness&quot;:
      if &quot;: ReceiverKeySimple&quot; in line:
        l1.append(num)
      elif &quot;senc(xsimple&quot; in line or &quot;senc(~xsimple&quot; in line:
        l2.append(num)
      elif &quot;KU( ~key&quot; in line:
        l3.append(num)

  else:
    exit(0)

ranked = l1 + l2 + l3

for i in ranked:
  print(i)</code></pre>
      <p>Having saved the Tamarin theory in the file
      <code>SourceOfUniqueness.spthy</code> and the oracle in the file
      <code>myoracle</code>, we can prove the lemma
      <code>uniqueness</code>, using the following command.</p>
      <pre><code>tamarin-prover --prove=uniqueness SourceOfUniqueness.spthy</code></pre>
      <p>The generated proof consists of only 10 steps. (162 steps with
      ‘consecutive’ ranking, non-termination with ‘smart’ ranking).</p>
      <p>Sometimes, one makes mistakes when writing an oracle or forgets
      to address a case in which the oracle would need to rank a goal
      for termination. For example in the oracle above, it could happen
      that none of the three checks apply to any of the goals and the
      oracle prints nothing. To help debugging oracles, the interactive
      mode of Tamarin provides an autoprove option that stops proving
      whenever the oracle ranks no goals (it is called
      <code>o. autoprove until oracle returns nothing</code>). This way,
      you can easily find and inspect the cases in which you might need
      to refine your oracle.</p>
      <!--Advanced Encoding
      ----------------------------

      to encoding using alternative more efficient descriptions-->
      <h2 id="manual-exploration-using-gui">Manual Exploration using
      GUI</h2>
      <p>See Section <a href="003_example.html#sec:gui">Example</a> for
      a short demonstration of the main features of the GUI.</p>
      <!-- downloading proofs, keyboard commands (a vs A vs b vs B) etc. -->
      <h3 id="disabling-server-access-logs">Disabling Server Access
      Logs</h3>
      <p>Sometimes the web server access logs can be too noisy if you
      are trying to do print debugging while using the interactive mode.
      The logs are on by default but can be disabled with the
      <code>--no-logging</code> CLI argument.</p>
      <pre><code>tamarin-prover interactive --no-logging &lt;Theory&gt;</code></pre>
      <p>This will run Tamarin in interactive mode and suppress the web
      server logs.</p>
      <h2 id="sec:channel-models">Different Channel Models</h2>
      <p>Tamarin’s built-in adversary model is often referred to as the
      Dolev-Yao adversary. This models an active adversary that has
      complete control of the communication network. Hence this
      adversary can eavesdrop on, block, and modify messages sent over
      the network and can actively inject messages into the network. The
      injected messages though must be those that the adversary can
      construct from his knowledge, i.e., the messages he initially
      knew, the messages he has learned from observing network traffic,
      and the messages that he can construct from messages he knows.</p>
      <p>The adversary’s control over the communication network is
      modeled with the following two built-in rules:</p>
      <ol type="1">
      <li></li>
      </ol>
      <pre><code>rule irecv:
   [ Out( x ) ] --&gt; [ !KD( x ) ]</code></pre>
      <ol start="2" type="1">
      <li></li>
      </ol>
      <pre><code>rule isend:
   [ !KU( x ) ] --[ K( x ) ]-&gt; [ In( x ) ]</code></pre>
      <p>The <code>irecv</code> rule states that any message sent by an
      agent using the <code>Out</code> fact is learned by the adversary.
      Such messages are then analyzed with the adversary’s message
      deduction rules, which depend on the specified equational
      theory.</p>
      <p>The <code>isend</code> rule states that any message received by
      an agent by means of the <code>In</code> fact has been constructed
      by the adversary.</p>
      <p>We can limit the adversary’s control over the protocol agents’
      communication channels by specifying channel rules, which model
      channels with intrinsic security properties. In the following, we
      illustrate the modelling of confidential, authentic, and secure
      channels. Consider for this purpose the following protocol, where
      an initiator generates a fresh nonce and sends it to a
      receiver.</p>
      <pre class="tamarin"><code>    I:  fresh(n)
    I -&gt; R: n </code></pre>
      <p>We can model this protocol as follows.</p>
      <pre class="tamarin"><code>/* Protocol */

rule I_1: 
    [ Fr(~n) ]
    --[ Send($I,~n), Secret_I(~n) ]-&gt; 
    [ Out(&lt;$I,$R,~n&gt;) ]
        
rule R_1:
    [ In(&lt;$I,$R,~n&gt;)  ]
    --[ Secret_R(~n), Authentic($I,~n) ]-&gt;
    [ ]

/* Security Properties */

lemma nonce_secret_initiator: 
    &quot;All n #i #j. Secret_I(n) @i &amp; K(n) @j ==&gt; F&quot;

lemma nonce_secret_receiver: 
    &quot;All n #i #j. Secret_R(n) @i &amp; K(n) @j ==&gt; F&quot;

lemma message_authentication: 
    &quot;All I n #j. Authentic(I,n) @j ==&gt; Ex #i. Send(I,n) @i &amp;i&lt;j&quot;</code></pre>
      <p>We state the nonce secrecy property for the initiator and
      responder with the <code>nonce_secret_initiator</code> and the
      <code>nonce_secret_receiver</code> lemma, respectively. The lemma
      <code>message_authentication</code> specifies a <a
      href="007_property-specification.html#sec:message-authentication">message
      authentication</a> property for the responder role.</p>
      <p>If we analyze the protocol with insecure channels, none of the
      properties hold because the adversary can learn the nonce sent by
      the initiator and send his own one to the receiver.</p>
      <h4 id="confidential-channel-rules">Confidential Channel
      Rules</h4>
      <p>Let us now modify the protocol such that the same message is
      sent over a confidential channel. By confidential we mean that
      only the intended receiver can read the message but everyone,
      including the adversary, can send a message on this channel.</p>
      <pre class="tamarin"><code>/* Channel rules */

rule ChanOut_C:
        [ Out_C($A,$B,x) ]
      --[ ChanOut_C($A,$B,x) ]-&gt;
        [ !Conf($B,x) ]

rule ChanIn_C:
        [ !Conf($B,x), In($A) ]
      --[ ChanIn_C($A,$B,x) ]-&gt;
        [ In_C($A,$B,x) ]

rule ChanIn_CAdv:
    [ In(&lt;$A,$B,x&gt;) ]
        --&gt;
        [ In_C($A,$B,x) ]

/* Protocol */

rule I_1: 
    [ Fr(~n) ]
      --[ Send($I,~n), Secret_I(~n) ]-&gt; 
    [ Out_C($I,$R,~n) ]
        
rule R_1:
    [ In_C($I,$R,~n)  ]
      --[ Secret_R(~n), Authentic($I,~n) ]-&gt;
    [ ]</code></pre>
      <p>The first three rules denote the channel rules for a
      confidential channel. They specify that whenever a message
      <code>x</code> is sent on a confidential channel from
      <code>$A</code> to <code>$B</code>, a fact
      <code>!Conf($B,x)</code> can be derived. This fact binds the
      receiver <code>$B</code> to the message <code>x</code>, because
      only he will be able to read the message. The rule
      <code>ChanIn_C</code> models that at the incoming end of a
      confidential channel, there must be a <code>!Conf($B,x)</code>
      fact, but any apparent sender <code>$A</code> from the adversary
      knowledge can be added. This models that a confidential channel is
      not authentic, and anybody could have sent the message.</p>
      <p>Note that <code>!Conf($B,x)</code> is a persistent fact. With
      this, we model that a message that was sent confidentially to
      <code>$B</code> can be replayed by the adversary at a later point
      in time. The last rule, <code>ChanIn_CAdv</code>, denotes that the
      adversary can also directly send a message from his knowledge on a
      confidential channel.</p>
      <p>Finally, we need to give protocol rules specifying that the
      message <code>~n</code> is sent and received on a confidential
      channel. We do this by changing the <code>Out</code> and
      <code>In</code> facts to the <code>Out_C</code> and
      <code>In_C</code> facts, respectively.</p>
      <p>In this modified protocol, the lemma
      <code>nonce_secret_initiator</code> holds. As the initiator sends
      the nonce on a confidential channel, only the intended receiver
      can read the message, and the adversary cannot learn it.</p>
      <h4 id="authentic-channel-rules">Authentic Channel Rules</h4>
      <p>Unlike a confidential channel, an adversary can read messages
      sent on an authentic channel. However, on an authentic channel,
      the adversary cannot modify the messages or their sender. We
      modify the protocol again to use an authentic channel for sending
      the message.</p>
      <pre class="tamarin"><code>/* Channel rules */

rule ChanOut_A:
    [ Out_A($A,$B,x) ]
    --[ ChanOut_A($A,$B,x) ]-&gt;
    [ !Auth($A,x), Out(&lt;$A,$B,x&gt;) ]

rule ChanIn_A:
    [ !Auth($A,x), In($B) ]
    --[ ChanIn_A($A,$B,x) ]-&gt;
    [ In_A($A,$B,x) ]

/* Protocol */

rule I_1: 
    [ Fr(~n) ]
    --[ Send($I,~n), Secret_I(~n) ]-&gt; 
    [ Out_A($I,$R,~n) ]
        
rule R_1:
    [ In_A($I,$R,~n)  ]
    --[ Secret_R(~n), Authentic($I,~n) ]-&gt;
    [ ]</code></pre>
      <p>The first channel rule binds a sender <code>$A</code> to a
      message <code>x</code> by the fact <code>!Auth($A,x)</code>.
      Additionally, the rule produces an <code>Out</code> fact that
      models that the adversary can learn everything sent on an
      authentic channel. The second rule says that whenever there is a
      fact <code>!Auth($A,x)</code>, the message can be sent to any
      receiver <code>$B</code>. This fact is again persistent, which
      means that the adversary can replay it multiple times, possibly to
      different receivers.</p>
      <p>Again, if we want the nonce in the protocol to be sent over the
      authentic channel, the corresponding <code>Out</code> and
      <code>In</code> facts in the protocol rules must be changed to
      <code>Out_A</code> and <code>In_A</code>, respectively. In the
      resulting protocol, the lemma <code>message_authentication</code>
      is proven by Tamarin. The adversary can neither change the sender
      of the message nor the message itself. For this reason, the
      receiver can be sure that the agent in the initiator role indeed
      sent it.</p>
      <h4 id="secure-channel-rules">Secure Channel Rules</h4>
      <p>The final kind of channel that we consider in detail are secure
      channels. Secure channels have the property of being both
      confidential and authentic. Hence an adversary can neither modify
      nor learn messages that are sent over a secure channel. However,
      an adversary can store a message sent over a secure channel for
      replay at a later point in time.</p>
      <p>The protocol to send the messages over a secure channel can be
      modeled as follows.</p>
      <pre class="tamarin"><code>/* Channel rules */

rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]-&gt;
        [ !Sec($A,$B,x) ]

rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]-&gt;
        [ In_S($A,$B,x) ]

/* Protocol */

rule I_1: 
    [ Fr(~n) ]
    --[ Send($I,~n), Secret_I(~n) ]-&gt; 
    [ Out_S($I,$R,~n) ]
        
rule R_1:
    [ In_S($I,$R,~n)  ]
    --[ Secret_R(~n), Authentic($I,~n) ]-&gt;
    [ ]</code></pre>
      <p>The channel rules bind both the sender <code>$A</code> and the
      receiver <code>$B</code> to the message <code>x</code> by the fact
      <code>!Sec($A,$B,x)</code>, which cannot be modified by the
      adversary. As <code>!Sec($A,$B,x)</code> is a persistent fact, it
      can be reused several times as the premise of the rule
      <code>ChanIn_S</code>. This models that an adversary can replay
      such a message block arbitrary many times.</p>
      <p>For the protocol sending the message over a secure channel,
      Tamarin proves all the considered lemmas. The nonce is secret from
      the perspective of both the initiator and the receiver because the
      adversary cannot read anything on a secure channel. Furthermore,
      as the adversary cannot send his own messages on the secure
      channel nor modify messages transmitted on the channel, the
      receiver can be sure that the nonce was sent by the agent who he
      believes to be in the initiator role.</p>
      <p>Similarly, one can define other channels with other properties.
      For example, we can model a secure channel with the additional
      property that it does not allow for replay. This could be done by
      changing the secure channel rules above by chaining
      <code>!Sec($A,$B,x)</code> to be a linear fact
      <code>Sec($A,$B,x)</code>. Consequently, this fact can only be
      consumed once and not be replayed by the adversary at a later
      point in time. In a similar manner, the other channel properties
      can be changed and additional properties can be imagined.</p>
      <h2 id="induction">Induction</h2>
      <p>Tamarin’s constraint solving approach is similar to a backwards
      search, in the sense that it starts from later states and reasons
      backwards to derive information about possible earlier states. For
      some properties, it is more useful to reason forwards, by making
      assumptions about earlier states and deriving conclusions about
      later states. To support this, Tamarin offers a specialised
      inductive proof method.</p>
      <p>We start by motivating the need for an inductive proof method
      on a simple example with two rules and one lemma:</p>
      <pre class="tamarin"><code>rule start:
  [ Fr(x) ]
--[ Start(x) ]-&gt;
  [ A(x) ]

rule repeat:
  [ A(x) ]
--[ Loop(x) ]-&gt;
  [ A(x) ]

lemma AlwaysStarts [use_induction]:
  &quot;All x #i. Loop(x) @i ==&gt; Ex #j. Start(x) @j&quot;</code></pre>
      <p>If we try to prove this with Tamarin without using induction
      (comment out the <code>[use_induction]</code> to try this) the
      tool will loop on the backwards search over the repeating
      <code>A(x)</code> fact. This fact can have two sources, either the
      <code>start</code> rule, which ends the search, or another
      instantiation of the <code>loop</code> rule, which continues.</p>
      <p>The induction method works by distinguishing the last timepoint
      <code>#i</code> in the trace, as <code>last(#i)</code>, from all
      other timepoints. It assumes the property holds for all other
      timepoints than this one. As these other time points must occur
      earlier, this can be understood as a form of <em>wellfounded
      induction</em>. The induction hypothesis then becomes an
      additional constraint during the constraint solving phase and
      thereby allows more properties to be proven.</p>
      <p>This is particularly useful when reasoning about action facts
      that must always be preceded in traces by some other action facts.
      For example, induction can help to prove that some later protocol
      step is always preceded by the initialization step of the
      corresponding protocol role, with similar parameters.</p>
      <p>Induction, however, does not work for all types of lemmas. Let
      us investigate the limitations of induction now as well. Consider
      another rule and lemma, added to the model from above.</p>
      <pre class="tamarin"><code>rule finish:
  [ A(x) ]
--[ End(x) ]-&gt;
  []

lemma AlwaysStartsWhenEnds [use_induction]:
  &quot;All x #i. End(x) @i ==&gt; Ex #j. Start(x) @j&quot;</code></pre>
      <p>Tamarin will fail to prove the
      <code>AlwaysStartsWhenEnds</code> lemma, although we apply
      induction. The induction hypothesis here is that
      <code>AlwaysStartsWhenEnds</code> holds but not at the last
      time-point; or more detailed: If there is an <code>End(x)</code>
      but not at the last time-point, then there is a
      <code>Start(x)</code> but not at the last time-point.</p>
      <p>We cannot apply this induction hypothesis fruitfully, though,
      as there will be always only one instance of <code>End(~x)</code>,
      which will be at the last time-point. Intuitively speaking,
      induction can only be applied fruitfully if the facts, on which
      the lemma “depends” (e.g., on the left-hand side of an
      implication), occur multiple times in the trace. Usually, this
      applies to facts that “loop”.</p>
      <p>Often, one can engineer around this restriction by connecting
      non-looping facts to looping facts using auxiliary lemmas. In the
      above example, the <code>AlwaysStarts</code> lemma provides such a
      connection. If you mark it as a <code>reuse</code> lemma, you can
      easily prove <code>AlwaysStartsWhenEnds</code> without
      induction.</p>
      <h2 id="sec:integrated-preprocessor">Integrated Preprocessor</h2>
      <p>Tamarin’s integrated preprocessor can be used to include or
      exclude parts of your file. You can use this, for example, to
      restrict your focus to just some subset of lemmas, or enable
      different behaviors in the modeling. This is done by putting the
      relevant part of your file within an <code>#ifdef</code> block
      with a keyword <code>KEYWORD</code></p>
      <pre><code>#ifdef KEYWORD
...
#endif</code></pre>
      <p>and then running Tamarin with the option <code>-DKEYWORD</code>
      to have this part included. In addition, a keyword can also be set
      to true with</p>
      <pre><code>#define KEYWORD</code></pre>
      <p>Boolean formulas in the conditional are also allowed as well as
      else branches</p>
      <pre><code>#ifdef (KEYWORD1 &amp; KEYWORD2) | KEYWORD3
...
#else
...
#endif</code></pre>
      <p>If you use this feature to exclude source lemmas, your case
      distinctions will change, and you may no longer be able to
      construct some proofs automatically. Similarly, if you have
      <code>reuse</code> marked lemmas that are removed, then other
      following lemmas may no longer be provable.</p>
      <p>The following is an example of a lemma that will be included
      when <code>timethis</code> is given as parameter to
      <code>-D</code>:</p>
      <pre class="tamarin"><code>#ifdef timethis
lemma tobemeasured:
  exists-trace
  &quot;Ex r #i. Action1(r)@i&quot;
#endif</code></pre>
      <p>At the same time this would be excluded:</p>
      <pre class="tamarin"><code>#ifdef nottimed
lemma otherlemma2:
  exists-trace
  &quot;Ex r #i. Action2(r)@i&quot;
#endif</code></pre>
      <p>The preprocessor also allows to include another file inside
      your main file.</p>
      <pre><code>#include &quot;path/to/myfile.spthy&quot;</code></pre>
      <p>The path can be absolute or relative to the main file. Included
      files can themselves contain other preprocessing flags, and the
      include behavior is recursive.</p>
      <h2 id="how-to-time-proofs-in-tamarin">How to Time Proofs in
      Tamarin</h2>
      <p>If you want to measure the time taken to verify a particular
      lemma you can use the previously described preprocessor to mark
      each lemma, and only include the one you wish to time. This can be
      done, for example, by wrapping the relevant lemma within
      <code>#ifdef timethis</code>. Also make sure to include
      <code>reuse</code> and <code>sources</code> lemmas in this. All
      other lemmas should be covered under a different keyword; in the
      example here we use <code>nottimed</code>.</p>
      <p>By running</p>
      <pre><code>time tamarin-prover -Dtimethis TimingExample.spthy --prove</code></pre>
      <p>the timing are computed for just the lemmas of interest. Here
      is the complete input file, with an artificial protocol:</p>
      <pre class="tamarin"><code>/*
This is an artificial protocol to show how to include/exclude parts of
the file based on the built-in preprocessor, particularly for timing
of lemmas.
*/

theory TimingExample
begin

rule artificial:
    [ Fr(~f) ]
  --[ Action1(~f) , Action2(~f) ]-&gt;
    [ Out(~f) ]

#ifdef nottimed
lemma otherlemma1:
  exists-trace
  &quot;Ex r #i. Action1(r)@i &amp; Action2(r)@i&quot;
#endif

#ifdef timethis
lemma tobemeasured:
  exists-trace
  &quot;Ex r #i. Action1(r)@i&quot;
#endif

#ifdef nottimed
lemma otherlemma2:
  exists-trace
  &quot;Ex r #i. Action2(r)@i&quot;
#endif

end</code></pre>
      <h2 id="configure-the-number-of-threads-used-by-tamarin">Configure
      the Number of Threads Used by Tamarin</h2>
      <p>Tamarin uses multi-threading to speed up the proof search. By
      default, Haskell automatically counts the number of cores
      available on the machine and uses the same number of threads.</p>
      <p>Using the options of Haskell’s run-time system this number can
      be manually configured. To use x threads, add the parameters</p>
      <pre><code>+RTS -Nx -RTS</code></pre>
      <p>to your Tamarin call, e.g.,</p>
      <pre><code>tamarin-prover Example.spthy --prove +RTS -N2 -RTS</code></pre>
      <p>to prove the lemmas in file <code>Example.spthy</code> using
      two cores.</p>
      <h2 id="equation-store">Equation Store</h2>
      <p>Tamarin stores equations in a special form to allow delaying
      case splits on them. This allows us for example to determine the
      shape of a signed message without case splitting on its variants.
      In the GUI, you can see the equation store being pretty printed as
      follows.</p>
      <pre><code>  free-substitution

  1. fresh-substitution-group
  ...
  n. fresh substitution-group</code></pre>
      <p>The free-substitution represents the equalities that hold for
      the free variables in the constraint system in the usual normal
      form, i.e., a substitution. The variants of a protocol rule are
      represented as a group of substitutions mapping free variables of
      the constraint system to terms containing only fresh variables.
      The different fresh-substitutions in a group are interpreted as a
      disjunction.</p>
      <p>Logically, the equation store represents expression of the
      form</p>
      <pre><code>      x_1 = t_free_1
    &amp; ...
    &amp; x_n = t_free_n
    &amp; ( (Ex y_111 ... y_11k. x_111 = t_fresh_111 &amp; ... &amp; x_11m = t_fresh_11m)
      | ...
      | (Ex y_1l1 ... y_1lk. x_1l1 = t_fresh_1l1 &amp; ... &amp; x_1lm = t_fresh_1lm)
      )
    &amp; ..
    &amp; ( (Ex y_o11 ... y_o1k. x_o11 = t_fresh_o11 &amp; ... &amp; x_o1m = t_fresh_o1m)
      | ...
      | (Ex y_ol1 ... y_olk. x_ol1 = t_fresh_ol1 &amp; ... &amp; x_1lm = t_fresh_1lm)
      )</code></pre>
      <h2 id="subterms">Subterms</h2>
      <p>The subterm predicate (written <code>&lt;&lt;</code> or
      <code>⊏</code>) captures a dependency relation on terms. It can be
      used just as <code>=</code> in lemmas and restrictions.
      Intuitively, if <code>x</code> is a subterm of <code>t</code>,
      then <code>x</code> is needed to compute <code>t</code>. This
      relation is a strict partial order, satisfies transitivity, and,
      most importantly, is consistent with the equational theory. For
      example, <code>x⊏h(x)</code> and also
      <code>c ++ a ⊏ a ++ b ++ c</code> hold.</p>
      <p>It gets more complicated when working with operators that are
      on top of a rewriting rule’s left side (excluding AC rules), e.g.,
      <code>fst</code>/<code>snd</code> for pairs:
      <code>fst(&lt;a,b&gt;) ↦ a</code>, <code>⊕</code> for xor and
      <code>adec</code>/<code>sdec</code> for decryption. We call these
      operators <em>reducible</em>. These cases do not happen in
      practice as, it is not even clear what the relation intuitively
      means, e.g., for <code>x⊏x⊕y</code> one could argue that
      <code>x</code> was needed to construct <code>x⊕y</code> but if
      <code>y</code> is instantiated with <code>x</code>, then
      <code>x⊕y=x⊕x=0</code> which clearly does not contain
      <code>x</code>.</p>
      <h4 id="non-provable-lemmas">Non-Provable Lemmas</h4>
      <p>Tamarins reasoning for subterms works well for irreducible
      operators. For reducible operators, however, the following
      situation can appear: No more goals are left but there are
      reducible operators in subterms. Usually, we have found a trace if
      no goals are left. However, if we have, e.g., <code>x⊏x⊕y</code>
      as a constraint left, then our constraint solving algorithm cannot
      solve this constraint, i.e., it is not clear whether we found a
      trace. In such a situation, Tamarin indicates with a yellow color
      in the proof tree that this part of the proof cannot be completed,
      i.e., there could be a trace, but we’re not sure. Even with such a
      yellow part, it can be that we find a trace in another part of the
      proof tree and prove an <code>exists-trace</code> lemma.</p>
      <p>In the following picture one can see the subterm with the
      reducible operator <code>fst</code> on the right side. Therefore,
      on the left side, the proof is marked yellow (with the blue line
      marking the current position). Also, this example demonstrates in
      <code>lemma GreenYellow</code>, that in an
      <code>exists-trace</code> lemma, a trace can be still found and
      the lemma proven even if there is a part of the proof that cannot
      be finished. Analogously, <code>lemma RedYellow</code>
      demonstrates that a <code>all-traces</code> lemma can still be
      disproven if a violating trace was found. The last two lemmas are
      ones where no traces were found in the rest of the proof, thus the
      overall result of the computation is
      <code>Tamarin cannot prove this property</code>.</p>
      <p><img src="../images/YellowSubterms.png" title="Subterms"
      alt="Subterms" /><br />
      </p>
      <h4 id="subterm-store">Subterm Store</h4>
      <p>Subterms are solved by recursively deconstructing the right
      side which basically boils down to replacing
      <code>t ⊏ f(t1,...,tn)</code> by the disjunction
      <code>t=t1 ∨ t⊏t1 ∨ ··· ∨ t=tn ∨ t⊏tn</code>. This disjunction can
      be quite large, so we want to delay it if not needed. The subterm
      store is the tool to do exactly this. It collects subterms,
      negative subterms (e.g., <code>¬ x ⊏ h(y)</code> being split to
      <code>x≠y ∧ ¬x⊏y</code>) and solved subterms which were already
      split. With this collection, many simplifications can be applied
      without splitting, especially concerning transitivity.</p>
      <p>Subterms are very well suited for <code>nat</code> terms as it
      reflects the smaller-than relation on natural numbers. Therefore,
      Tamarin provides special algorithms in deducing contradictions on
      natural numbers. Notably, if we are looking at natural numbers, we
      can deduce <code>x⊏y</code> from <code>(¬y⊏x ∧ x≠y)</code> which
      is not possible for normal subterms.</p>
      <p>For more detailed explanations on subterms and numbers, look at
      the paper “Subterm-based proof techniques for improving the
      automation and scope of security protocol analysis” which
      introduced subterms and numbers to Tamarin.</p>
      <h2
      id="reasoning-about-exclusivity-facts-symbols-with-injective-instances">Reasoning
      about Exclusivity: Facts Symbols with Injective Instances</h2>
      <p>We say that a fact symbol <code>F</code> has <em>injective
      instances</em> with respect to a multiset rewriting system
      <code>R</code>, if there is no reachable state of the multiset
      rewriting system <code>R</code> with more than one instance of an
      <code>F</code>-fact with the same term as a first argument.
      Injective facts typically arise from modeling databases using
      linear facts. An example of a fact with injective instances is the
      <code>Store</code>-fact in the following multiset rewriting
      system.</p>
      <pre><code>  rule CreateKey: [ Fr(handle), Fr(key) ] --&gt; [ Store(handle, key) ]

  rule NextKey:   [ Store(handle, key) ] --&gt; [ Store(handle, h(key)) ]

  rule DelKey:    [ Store(handle,key) ] --&gt; []</code></pre>
      <p>When reasoning about the above multiset rewriting system, we
      exploit that <code>Store</code> has injective instances to prove
      that after the <code>DelKey</code> rule no other rule using the
      same handle can be applied. This proof uses trace induction and
      the following constraint-reduction rule that exploits facts with
      unique instances.</p>
      <p>Let <code>F</code> be a fact symbol with injective instances.
      Let <code>i</code>, <code>j</code>, and <code>k</code> be temporal
      variables ordered according to</p>
      <pre><code>  i &lt; j &lt; k</code></pre>
      <p>and let there be an edge from <code>(i,u)</code> to
      <code>(k,w)</code> for some indices <code>u</code> and
      <code>v</code>, as well as an injective fact <code>F(t,...)</code>
      in the conclusion <code>(i,u)</code>.</p>
      <p>Then, we have a contradiction either if: 1) both the premises
      <code>(k,w)</code> and <code>(j,v)</code> are consuming and
      require a fact <code>F(t,...)</code>. 2) both the conclusions
      <code>(i,u)</code> and <code>(j,v)</code> produce a fact
      <code>F(t,..)</code>.</p>
      <p>In the first case, <code>(k,w)</code> and <code>(j,v)</code>
      would have to be merged, and in the second case <code>(i,u)</code>
      and <code>(j,v)</code> would have to be merged. This is because
      the edge <code>(i,u) &gt;-&gt; (k,w)</code> crosses <code>j</code>
      and the state at <code>j</code> therefore contains
      <code>F(t,...)</code>. The merging is not possible due to the
      ordering constraints <code>i &lt; j &lt; k</code>.</p>
      <h4 id="detection-of-injective-facts">Detection of Injective
      Facts</h4>
      <p>Note that computing the set of fact symbols with injective
      instances is undecidable in general. We therefore compute an
      under-approximation to this set using the following simple
      heuristic:</p>
      <p>We check for each occurrence of the fact-tag in a rule that
      there is no other occurrence with the same first term and 1.
      either there is a Fr-fact of the first term as a premise 2. or
      there is exactly one consume fact-tag with the same first term in
      a premise</p>
      <p>We exclude facts that are not copied in a rule, as they are
      already handled properly by the naive backwards reasoning.</p>
      <p>Additionally, we determine the monotonic term positions which
      are - Constant (<code>=</code>) - Increasing/Decreasing
      (<code>&lt;</code>/<code>&gt;</code>) - Strictly
      Increasing/Decreasing (<code>≤</code>/<code>≥</code>) Positions
      can also be inside tuples if these tuples are always explicitly
      used in the rules.</p>
      <p>In the example above, the <code>key</code> in
      <code>Store</code> is strictly increasing as <code>key</code> is a
      syntactic subterm of <code>h(key)</code> and <code>h</code> is not
      a reducible operator (not appearing on the top of a rewriting
      rules left side).</p>
      <p>These detected injective facts can be viewed on the top of the
      right side when clicking on “Message Rewriting Rules”. The Store
      would look as follows: <code>Store(id,&lt;)</code> indicating that
      the first term is for identification of the injective fact while
      the second term is strictly increasing. Possible symbols are
      <code>≤</code>, <code>≥</code>, <code>&lt;</code>,
      <code>&gt;</code> and <code>=</code>. A tuple position is marked
      with additional parantheses, e.g.,
      <code>Store(id,(&lt;,≥),=)</code>.</p>
      <p>Note that this support for reasoning about exclusivity was
      sufficient for our case studies, but it is likely that more
      complicated case studies require additional support. For example,
      that fact symbols with injective instances can be specified by the
      user and the soundness proof that these symbols have injective
      instances is constructed explicitly using the Tamarin prover.
      Please tell us, if you encounter limitations in your case studies:
      https://github.com/tamarin-prover/tamarin-prover/issues.</p>
      <h4 id="monotonicity">Monotonicity</h4>
      <p>With the monotonic term positions, we can additionally reason
      as follows: if there are two instances at positions <code>i</code>
      and <code>j</code> of an injective fact with the same first term,
      then - for each two terms <code>s</code>,<code>t</code> at a
      constant position - (1) <code>s=t</code> is deduced - for each two
      terms <code>s</code>,<code>t</code> at a strictly increasing
      position: - (2) if <code>s=t</code>, then <code>i=j</code> is
      deduced - (3) if <code>s⊏t</code>, then <code>i&lt;j</code> is
      deduced - (4) if <code>i&lt;j</code> or <code>j&lt;i</code>, then
      <code>s≠t</code> is deduced - (5) if <code>¬s⊏t</code> and
      <code>¬s=t</code>, then <code>j&lt;i</code> is deduced (as t⊏s
      must hold because of monotonicity) - for each two terms
      <code>s</code>,<code>t</code> at an increasing position: - (3) if
      <code>s⊏t</code>, then <code>i&lt;j</code> is deduced - (5) if
      <code>¬s⊏t</code> and <code>¬s=t</code>, then <code>j&lt;i</code>
      is deduced (as t⊏s must hold because of monotonicity) - for
      decreasing and strictly decreasing, the inverse of the increasing
      cases holds</p>
      <h2 id="convenience-functions-for-print-debugging">Convenience
      Functions for Print Debugging</h2>
      <p>For debugging Haskell programs it is still convenient to use
      simple print debugging. The standard library includes the
      <code>Debug.trace</code> family of functions that can even be used
      from a pure context to print debug output. Since adding too many
      debug prints can lead to a noisy output we implement some
      convenience functions on top of <code>Debug.trace</code>, which
      can be selectively turned on when debugging a certain section of
      the code.</p>
      <p>The following functions are implemented in the
      <code>Debug.Trace.EnvTracer</code> module. Functions usable in an
      Applicative/Monad have an “M” suffix.</p>
      <pre><code>etraceSectionLn :: String -&gt; String -&gt; b -&gt; b    
etraceSectionLnM :: Applicative f =&gt; String -&gt; String -&gt; f ()
etraceLn :: String -&gt; String -&gt; String -&gt; b -&gt; b    
etraceLnM :: Applicative f =&gt; String -&gt; String -&gt; String -&gt; f ()</code></pre>
      <p>The first argument to all functions is a <em>trace key</em>
      string. When running Tamarin you can set the
      <code>DEBUG_TRACE</code> environment variable to a comma-separated
      list of trace keys, which will then enable the corresponding debug
      outputs. Any debug trace whose key is not contained in the
      environment variable will be suppressed.</p>
      <p>The <code>etraceSectionLn*</code> functions are used to make
      visual separators for debug outputs. The <code>etraceLn*</code>
      functions take a label to give context and an arbitrary string to
      print.</p>
      <p>For example, the following example program would result in the
      debug output below if the <code>DEBUG_TRACE</code> variable
      contains “foo”.</p>
      <pre><code>etraceSectionLn &quot;foo&quot; &quot;TITLE&quot; $
etraceLn &quot;foo&quot; &quot;functionA&quot; &quot;called functionA&quot; $
...

=== TITLE ======================================================================
functionA: called functionA</code></pre>
      <h2
      id="outputting-constraint-systems-when-satisfying-traces-are-found.">Outputting
      constraint systems when satisfying traces are found.</h2>
      <p>It can be useful for further analysis to output the constraint
      system of the state of the proof of a lemma when either a
      satisfying trace is found in an “exists-trace” lemma, or when a
      counterexample trace is found in an “all-traces” lemma. For this
      you can use the command line options <code>--output-json</code>
      (or <code>--oj</code>) and <code>--output-dot</code> (or
      <code>--od</code>) in the non-interactive mode of tamarin. The
      command line options take a required filename and will output all
      those constraint systems into the file in the respective
      format.</p>
      <pre><code>tamarin-prover --prove --output-json=traces.json --output-dot=traces.dot examples/Tutorial.spthy</code></pre>
      <p>For dot, the file is simply the concatenation of all ‘digraph’
      expressions, which can then be rendered into individual image
      files using the <code>-O</code> option of the dot command line
      program.</p>
      <pre><code># will output images to traces.dot.png, traces.dot.2.png, traces.dot.3.png, ...
dot -Tpng -O traces.dot</code></pre>
      <p>For JSON, the standard schema already defines a single
      top-level object with a “graphs” key that holds a list of the
      individual graphs, which we use to output the constrain
      systems.</p>
      <div id="refs" class="references csl-bib-body hanging-indent"
      data-entry-spacing="0" role="list">
      <div id="ref-KK-jcs16" class="csl-entry" role="listitem">
      Kremer, Steve, and Robert Künnemann. 2016. <span>“Automated
      Analysis of Security Protocols with Global State.”</span>
      <em>Journal of Computer Security</em> 24 (5): 583–616. <a
      href="https://doi.org/10.3233/JCS-160556">https://doi.org/10.3233/JCS-160556</a>.
      </div>
      </div>
    </div>
  </div>
</body>

</html>
