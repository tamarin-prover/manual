<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tamarin Prover Manual</title>
    <link rel="stylesheet" type="text/css" href="book.css">
    <script src="book.js"></script>
    <link rel="stylesheet" href="styles/github.css">
<!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
    </head>
<body class="tamarindoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
    <span class="sr-only">Toggle navigation</span>
    <span class="bar"></span>
    <span class="bar"></span>
    <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
  <ul class='chapter'>
<!-- <li><a href='000_prelims.html'                    ><b>0. </b>Preliminaries</a></li> -->
<li><a href='001_introduction.html'               ><b>1. </b> Introduction</a></li>
<li><a href='002_installation.html'               ><b>2. </b> Installation</a></li>
<li><a href='003_example.html'                    ><b>3. </b> First Example</a></li>
<li><a href='004_cryptographic-messages.html'     ><b>4. </b> Cryptographic Messages</a></li>
<li><a href='005_protocol-specification.html'     ><b>5. </b> Protocol Specification</a></li>
<li><a href='006_property-specification.html'     ><b>6. </b> Property Specification</a></li>
<li><a href='007_precomputation.html'             ><b>7. </b> Precomputation</a></li>
<li><a href='008_modeling-issues.html'            ><b>8. </b> Modeling Issues</a></li>
<li><a href='009_advanced-features.html'          ><b>9. </b> Advanced Features</a></li>
<li><a href='010_case-studies.html'               ><b>10.</b> Case Studies</a></li>
<li><a href='011_toolchains.html'                 ><b>11.</b> Toolchains</a></li>
<li><a href='012_limitations.html'                ><b>12.</b> Limitations</a></li>
<li><a href='013_contact-and-further-reading.html'><b>13.</b> Contact Information and Further Reading</a></li>
<li><a href='014_syntax_description.html'         ><b>14.</b> Syntax Description</a></li>
  </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
<p class="halfbreak">
</p>
<h1 id="syntax-description">Syntax Description</h1>
<p>Here, we explain the formal syntax of the security protocol theory format that is processed by Tamarin.</p>
<p>Comments are C-style:</p>
<pre><code>/* for a multi-line comment */
// for a line-comment</code></pre>
<p>All security protocol theory are named and delimited by <code>begin</code> and <code>end</code>. We explain the non-terminals of the body in the following paragraphs.</p>
<pre><code>security_protocol_theory := &#39;theory&#39; ident &#39;begin&#39; body &#39;end&#39;
body := (signature_spec | global_heuristic | rule |
            restriction | lemma | formal_comment)*</code></pre>
<p>Here, we use the term signature more liberally to denote both the defined function symbols and the equalities describing their interaction. Note that our parser is stateful and remembers what functions have been defined. It will only parse function applications of defined functions.</p>
<pre><code>signature_spec := functions | equations | built_in
functions      := &#39;functions&#39; &#39;:&#39; function_sym (&#39;,&#39; function_sym)*
function_sym   := ident &#39;/&#39; arity [&#39;[private]&#39;]
arity          := digit+
equations      := &#39;equations&#39; &#39;:&#39; equation (&#39;,&#39; equation)*
equation       := (term &#39;=&#39; term)</code></pre>
<p>Note that the equations must be convergent and have the Finite Variant Property (FVP), and do not allow the use of fixed public names in the terms. Tamarin provides built-in sets of function definitions and equations. They are expanded upon parsing and you can therefore inspect them by pretty printing the file using <code>tamarin-prover your_file.spthy</code>. The built-in <code>diffie-hellman</code> is special. It refers to the equations given in Section <a href="004_cryptographic-messages.html#sec:equational-theories">Cryptographic Messages</a>. You need to enable it to parse terms containing exponentiations, e.g., g ^ x.</p>
<pre><code>built_in       := &#39;builtins&#39; &#39;:&#39; built_ins (&#39;,&#39; built_ins)*
built_ins      := &#39;diffie-hellman&#39;
                | &#39;hashing&#39; | &#39;symmetric-encryption&#39;
                | &#39;asymmetric-encryption&#39; | &#39;signing&#39;
                | &#39;bilinear-pairing&#39; | &#39;xor&#39;
                | &#39;multiset&#39; | &#39;revealing-signing&#39;</code></pre>
<p>A global heuristic sets the default heuristic that will be used when autoproving lemmas in the file. The specified heuristic can be any of those discussed in Section <a href="009_advanced-features.html#sec:heuristics">Heuristics</a>.</p>
<pre><code>global_heuristic := &#39;heuristic&#39; &#39;:&#39; heuristic
heuristic        := alpha+</code></pre>
<p>Multiset rewriting rules are specified as follows. The protocol corresponding to a security protocol theory is the set of all multiset rewriting rules specified in the body of the theory.</p>
<pre><code>rule := &#39;rule&#39; [modulo] ident [rule_attrs] &#39;:&#39;
        [let_block]
        &#39;[&#39; facts &#39;]&#39; ( &#39;--&gt;&#39; | &#39;--[&#39; facts &#39;]-&gt;&#39;) &#39;[&#39; facts &#39;]&#39;
modulo     := &#39;(&#39; &#39;modulo&#39; (&#39;E&#39; | &#39;AC&#39;) &#39;)&#39;
rule_attrs := &#39;[&#39; rule_attr (&#39;,&#39; rule_attr)* &#39;]&#39;
rule_attr  := (&#39;color=&#39; | &#39;colour=&#39;) hexcolor
let_block  := &#39;let&#39; (msg_var &#39;=&#39; msetterm)+ &#39;in&#39;
msg_var    := ident [&#39;.&#39; natural] [&#39;:&#39; &#39;msg&#39;]</code></pre>
<p>Rule annotations do not influence the rule's semantics. A color is represented as a triplet of 8 bit hexadecimal values optionally preceded by '#', and is used as the background color of the rule when it is rendered in graphs.</p>
<p>The let-block allows more succinct specifications. The equations are applied in a bottom-up fashion. For example,</p>
<pre><code>let x = y
    y = &lt;z,x&gt;
in [] --&gt; [ A(y)]    is desugared to    [] --&gt; [ A(&lt;z,y&gt;) ]</code></pre>
<p>This becomes a lot less confusing if you keep the set of variables on the left-hand side separate from the free variables on the right-hand side.</p>
<p>Restrictions specify restrictions on the set of traces considered, i.e., they filter the set of traces of a protocol. The formula of a restriction is available as an assumption in the proofs of <em>all</em> security properties specified in this security protocol theory.</p>
<pre><code>restriction := &#39;restriction&#39; ident &#39;:&#39; &#39;&quot;&#39; formula &#39;&quot;&#39;</code></pre>
<p>In observational equivalence mode, restrictions can be associated to one side.</p>
<pre><code>restriction := &#39;restriction&#39; ident [restriction_attrs] &#39;:&#39; &#39;&quot;&#39; formula &#39;&quot;&#39;
restriction_attrs      := &#39;[&#39; (&#39;left&#39; | &#39;right&#39;) &#39;]&#39;</code></pre>
<p>Lemmas specify security properties. By default, the given formula is interpreted as a property that must hold for all traces of the protocol of the security protocol theory. You can change this using the 'exists-trace' trace quantifier.</p>
<pre><code>lemma := &#39;lemma&#39; [modulo] ident [lemma_attrs] &#39;:&#39;
         [trace_quantifier]
         &#39;&quot;&#39; formula &#39;&quot;&#39;
         proof_skeleton
lemma_attrs      := &#39;[&#39; lemma_attr (&#39;,&#39; lemma_attr)* &#39;]&#39;
lemma_attr       := &#39;sources&#39; | &#39;reuse&#39; | &#39;use_induction&#39; |
                         &#39;hide_lemma=&#39; ident | &#39;heuristic=&#39; heuristic
trace_quantifier := &#39;all-traces&#39; | &#39;exists-trace&#39;</code></pre>
<p>In observational equivalence mode, lemmas can be associated to one side.</p>
<pre><code>lemma_attrs      := &#39;[&#39; (&#39;sources&#39; | &#39;reuse&#39; | &#39;use_induction&#39; | 
                         &#39;hide_lemma=&#39; ident | &#39;heuristic=&#39; heuristic |
                         &#39;left&#39; | &#39;right&#39;) &#39;]&#39;</code></pre>
<p>A proof skeleton is a complete or partial proof as output by the Tamarin prover. It indicates the proof method used at each step, which may include multiple cases.</p>
<pre><code>proof_skeleton :=  &#39;SOLVED&#39; | &#39;by&#39; proof_method
                | proof_method proof_skeleton
                | proof_method &#39;case&#39; ident proof_skeleton
                    (&#39;next &#39;case&#39; ident proof_skeleton)* &#39;qed&#39;
proof_method   := &#39;sorry&#39; | &#39;simplify&#39; | &#39;solve &#39;(&#39; goal &#39;)&#39; |
                  &#39;contradiction&#39; | &#39;induction&#39;
goal           :=  fact &quot;▶&quot; natural_subscr node_var
                | fact &#39;@&#39; node_var
                | &#39;(&#39; node_var &#39;,&#39; natural &#39;)&#39; &#39;~~&gt;&#39; &#39;(&#39; node_var &#39;,&#39; natural &#39;)&#39;
                | formula (&quot;∥&quot; formula)*
                | &#39;splitEqs&#39; &#39;(&#39; natural &#39;)&#39;
node_var       := [&#39;#&#39;] ident [&#39;.&#39; natural]      // temporal sort prefix
                | ident [&#39;.&#39; natural] &#39;:&#39; &#39;node&#39; // temporal sort suffix
natural        := digit+
natural_sub    := (&#39;₀&#39;|&#39;₁&#39;|&#39;₂&#39;|&#39;₃&#39;|&#39;₄&#39;|&#39;₅&#39;|&#39;₆&#39;|&#39;₇&#39;|&#39;₈&#39;|&#39;₉&#39;)+</code></pre>
<p>Formal comments are used to make the input more readable. In contrast to <code>/*...*/</code> and <code>//...</code> comments, formal comments are stored and output again when pretty-printing a security protocol theory.</p>
<pre><code>formal_comment := ident &#39;{*&#39; ident* &#39;*}&#39;</code></pre>
<p>For the syntax of terms, you best look at our examples. A common pitfall is to use an undefined function symbol. This results in an error message pointing to a position slightly before the actual use of the function due to some ambiguity in the grammar.</p>
<p>We provide special syntax for tuples, multisets, xors, multiplications, exponentiation, nullary and binary function symbols. An n-ary tuple <code>&lt;t1,...,tn&gt;</code> is parsed as n-ary, right-associative application of pairing. Multiplication and exponentiation are parsed left-associatively. For a binary operator <code>enc</code> you can write <code>enc{m}k</code> or <code>enc(m,k)</code>. For nullary function symbols, there is no need to write <code>nullary()</code>. Note that the number of arguments of an n-ary function application must agree with the arity given in the function definition.</p>
<pre><code>tupleterm := &#39;&lt;&#39; msetterm (&#39;,&#39; msetterm)* &#39;&gt;&#39;
msetterm  := xorterm (&#39;+&#39; xorterm)*
xorterm   := multterm ((&#39;XOR&#39; | ⊕) multterm)*
multterm  := expterm (&#39;*&#39; expterm)*
expterm   := term    (&#39;^&#39; term   )*
term      := tupleterm             // n-ary right-associative pairing
           | &#39;(&#39; msetterm &#39;)&#39;      // a nested term
           | nullary_fun
           | binary_app
           | nary_app
           | literal

nullary_fun := &lt;all-nullary-functions-defined-up-to-here&gt;
binary_app  := binary_fun &#39;{&#39; tupleterm &#39;}&#39; term
binary_fun  := &lt;all-binary-functions-defined-up-to-here&gt;
nary_app    := nary_fun &#39;(&#39; multterm* &#39;)&#39;

literal     := &quot;&#39;&quot;  ident &quot;&#39;&quot; // a fixed, public name
             | &quot;~&#39;&quot; ident &quot;&#39;&quot; // a fixed, fresh name
             | nonnode_var    // a non-temporal variable
nonnode_var := [&#39;$&#39;] ident [&#39;.&#39; natural]         // &#39;pub&#39; sort prefix
             | ident [&#39;.&#39; natural] &#39;:&#39; &#39;pub&#39;     // &#39;pub&#39; sort suffix
             | [&#39;~&#39;] ident [&#39;.&#39; natural]         // &#39;fresh&#39; sort prefix
             | ident [&#39;.&#39; natural] &#39;:&#39; &#39;fresh&#39;   // &#39;fresh&#39; sort suffix
             | msg_var                                // &#39;msg&#39; sort</code></pre>
<p>Facts do not have to be defined up-front. This will probably change once we implement user-defined sorts. Facts prefixed with <code>!</code> are persistent facts. All other facts are linear. There are six reserved fact symbols: In, Out, KU, KD, and K. KU and KD facts are used for construction and deconstruction rules. KU-facts also log the messages deduced by construction rules. Note that KU-facts have arity 2. Their first argument is used to track the exponentiation tags. See the <code>loops/Crypto_API_Simple.spthy</code> example for more information.</p>
<pre><code>facts := fact (&#39;,&#39; fact)*
fact  := [&#39;!&#39;] ident &#39;(&#39; [msetterm (&#39;,&#39; msetterm)*] &#39;)&#39; [fact_annotes]
fact_annotes := &#39;[&#39; fact_annote (&#39;,&#39; fact_annote)* &#39;]&#39;
fact_annote  := &#39;+&#39; | &#39;-&#39; | &#39;no_precomp&#39;</code></pre>
<p>Fact annotations can be used to adjust the priority of corresponding goals in the heuristics, or influence the precomputation step performed by Tamarin, as described in Section <a href="009_advanced-features.html#sec:fact-annotations">Advanced Features</a>.</p>
<p>Formulas are trace formulas as described previously. Note that we are a bit more liberal with respect to guardedness. We accept a conjunction of atoms as guards.</p>
<pre><code>formula     := imp [(&#39;&lt;=&gt;&#39; | &#39;⇔&#39;) imp]
imp         := disjunction [(&#39;==&gt;&#39; | &#39;⇒&#39;) imp]
disjunction := conjunction ((&#39;|&#39; | &#39;∨&#39;) conjunction)* // left-associative
conjunction := negation ((&#39;&amp;&#39; | &#39;∧&#39;) negation)*       // left-associative
negation    := [&#39;not&#39; | &#39;¬&#39;] atom
atom        := &#39;⊥&#39; | &#39;F&#39; | &#39;⊤&#39; | &#39;T&#39;        // true or false
             | &#39;(&#39; formula &#39;)&#39;          // nested formula
             | &#39;last&#39; &#39;(&#39; node_var &#39;)&#39;  // &#39;last&#39; temporal variable for induction
             | fact &#39;@&#39; node_var        // action
             | node_var &#39;&lt;&#39; node_var    // ordering of temporal variables
             | msetterm &#39;=&#39; msetterm    // equality of terms
             | node_var &#39;=&#39; node_var    // equality of temporal variables
             | (&#39;Ex&#39; | &#39;∃&#39; | &#39;All&#39; | &#39;∀&#39;) // quantified formula
                    lvar+ &#39;.&#39; formula

lvar        := node_var | nonnode_var</code></pre>
<p>Identifiers always start with a letter or number, and may contain underscores after the first character. Moreover, they must not be one of the reserved keywords <code>let</code>, <code>in</code>, or <code>rule</code>. Although identifiers beginning with a number are valid, they are not allowed as the names of facts (which must begin with an upper-case letter). ident := alphaNum (alphaNum | '_')*</p>
    </div>
  </div>
</body>
</html>
