<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tamarin Prover Manual</title>
    <link rel="stylesheet" type="text/css" href="book.css">
    <script src="book.js"></script>
    <link rel="stylesheet" href="styles/github.css">
<!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
    </head>
<body class="tamarindoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
    <span class="sr-only">Toggle navigation</span>
    <span class="bar"></span>
    <span class="bar"></span>
    <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
  <ul class='chapter'>
<!-- <li><a href='000_prelims.html'                    ><b>0. </b>Preliminaries</a></li> -->
<li><a href='001_introduction.html'               ><b>1. </b> Introduction</a></li>
<li><a href='002_installation.html'               ><b>2. </b> Installation</a></li>
<li><a href='003_example.html'                    ><b>3. </b> First Example</a></li>
<li><a href='004_cryptographic-messages.html'     ><b>4. </b> Cryptographic Messages</a></li>
<li><a href='005_protocol-specification.html'     ><b>5. </b> Protocol Specification</a></li>
<li><a href='006_property-specification.html'     ><b>6. </b> Property Specification</a></li>
<li><a href='007_precomputation.html'             ><b>7. </b> Precomputation</a></li>
<li><a href='008_modeling-issues.html'            ><b>8. </b> Modeling Issues</a></li>
<li><a href='009_advanced-features.html'          ><b>9. </b> Advanced Features</a></li>
<li><a href='010_case-studies.html'               ><b>10.</b> Case Studies</a></li>
<li><a href='011_toolchains.html'                 ><b>11.</b> Toolchains</a></li>
<li><a href='012_limitations.html'                ><b>12.</b> Limitations</a></li>
<li><a href='013_contact-and-further-reading.html'><b>13.</b> Contact Information and Further Reading</a></li>
<li><a href='014_syntax_description.html'         ><b>14.</b> Syntax Description</a></li>
  </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
<p class="halfbreak">
</p>
<h1 id="sec:property_specification">Property Specification</h1>
<p>In this section we present how to specify protocol properties as trace and observational equivalence properties, based on the action facts given in the model. Trace properties are given as guarded first-order logic formulas and observational equivalence properties are specified using the <code>diff</code> operator, both of which we will see in detail below.</p>
<h2 id="trace-properties">Trace Properties</h2>
<p>The Tamarin multiset rewriting rules define a labeled transition system. The system's state is a multiset (bag) of facts and the initial system state is the empty multiset. The rules define how the system can make a transition to a new state. The types of facts and their use are described in Section <a href="005_protocol-specification.html#sec:rules">Rules</a>. Here we focus on the <em>action facts</em>, which are used to reason about a protocol's behaviour.</p>
<p>A rule can be applied to a state if it can be instantiated such that its left hand side is contained in the current state. In this case, the left-hand side facts are removed from the state, and replaced by the instantiated right hand side. The application of the rule is recorded in the <em>trace</em> by appending the instantiated action facts to the trace.</p>
<p>For instance, consider the following fictitious rule</p>
<pre><code>rule fictitious:
   [ Pre(x), Fr(~n) ]
 --[ Act1(~n), Act2(x) ]--&gt;
   [ Out(&lt;x,~n&gt;) ]</code></pre>
<p>The rule rewrites the system state by consuming the facts <code>Pre(x)</code> and <code>Fr(~n)</code> and producing the fact <code>Out(&lt;x,~n&gt;)</code>. The rule is labeled with the actions <code>Act1(~n)</code> and <code>Act2(x)</code>. The rule can be applied if there are two facts <code>Pre</code> and <code>Fr</code> in the system state whose arguments are matched by the variables <code>x</code> and <code>~n</code>. In the application of this rule, <code>~n</code> and <code>x</code> are instantiated with the matched values and the state transition is labeled with the instantiations of <code>Act1(~n)</code> and <code>Act2(x)</code>. The two instantiations are considered to have occurred at the same timepoint.</p>
<p>A <em>trace property</em> is a set of traces. We define a set of traces in Tamarin using first-order logic formulas over action facts and timepoints. More precisely, Tamarin's property specification language is a guarded fragment of a many-sorted first-order logic with a sort for timepoints. This logic supports quantification over both messages and timepoints.</p>
<p>The syntax for specifying security properties is defined as follows:</p>
<ul>
<li><code>All</code> for universal quantification, temporal variables are prefixed with #</li>
<li><code>Ex</code> for existential quantification, temporal variables are prefixed with #</li>
<li><code>==&gt;</code> for implication</li>
<li><code>&amp;</code> for conjunction</li>
<li><code>|</code> for disjunction</li>
<li><p><code>not</code> for negation</p></li>
<li><p><code>f @ i</code> for action constraints, the sort prefix for the temporal variable 'i' is optional</p></li>
<li><p><code>i &lt; j</code> for temporal ordering, the sort prefix for the temporal variables 'i' and 'j' is optional</p></li>
<li><code>#i = #j</code> for an equality between temporal variables 'i' and 'j'</li>
<li><p><code>x = y</code> for an equality between message variables 'x' and 'y'</p></li>
</ul>
<p>All action fact symbols may be used in formulas. The terms (as arguments of those action facts) are more limited. Terms are only allowed to be built from quantified variables, public constants (names delimited using single-quotes), and free function symbols including pairing. This excludes function symbols that appear in any of the equations. Moreover, all variables must be guarded. If they are not guarded, Tamarin will produce an error.</p>
<p><strong>Guardedness. </strong> To ensure guardedness, for universally quantified variables, one has to check that they all occur in an action constraint right after the quantifier and that the outermost logical operator inside the quantifier is an implication. For existentially quantified variables, one has to check that they all occur in an action constraint right after the quantifier and that the outermost logical operator inside the quantifier is a conjunction. We do recommend to use parentheses, when in doubt about the precedence of logical connectives, but we follow the standard precedence. Negation binds tightest, then conjunction, then disjunction and then implication. <!-- Equivalence binds weakest (and nobody uses it). --></p>
<p>To specify a property about a protocol to be verified, we use the keyword <code>lemma</code> followed by a name for the property and a guarded first-order formula. This expresses that the property must hold for all traces of the protocol. For instance, to express the property that the fresh value <code>~n</code> is distinct in all applications of the fictitious rule (or rather, if an action with the same fresh value appears twice, it actually is the same instance, identified by the timepoint), we write</p>
<pre><code>lemma distinct_nonces: 
    &quot;All n #i #j. Act1(n)@i &amp; Act1(n)@j ==&gt; #i=#j&quot;</code></pre>
<p>or equivalently</p>
<pre><code>lemma distinct_nonces: 
  all-traces
    &quot;All n #i #j. Act1(n)@i &amp; Act1(n)@j ==&gt; #i=#j&quot;</code></pre>
<p>We can also express that there exists a trace for which the property holds. We do this by adding the keyword <code>exists-trace</code> after the name and before the property. For instance, the following lemma is true if and only if the preceding lemma is false:</p>
<pre><code>lemma distinct_nonces: 
  exists-trace 
    &quot;not All n #i #j. Act1(n)@i &amp; Act1(n)@j ==&gt; #i=#j&quot;</code></pre>
<h3 id="secrecy">Secrecy</h3>
<p>In this section we briefly explain how you can express standard secrecy properties in Tamarin and give a short example. See <a href="#sec:elsewhere">Protocol and Standard Security Property Specification Templates</a> for an in-depth discussion.</p>
<p>Tamarin's built-in message deduction rule</p>
<pre><code>rule isend: 
   [ !KU(x) ]
 --[  K(x)  ]--&gt;
   [ In(x)  ]</code></pre>
<p>allows us to reason about the Dolev-Yao adversary's knowledge. To specify the property that a message <code>x</code> is secret, we propose to label a suitable protocol rule with a <code>Secret</code> action. We then specify a secrecy lemma that states whenever the <code>Secret(x)</code> action occurs at timepoint <code>i</code>, the adversary does not know <code>x</code>.</p>
<pre><code>lemma secrecy:
  &quot;All x #i. 
    Secret(x) @i ==&gt; not (Ex #j. K(x)@j)&quot;</code></pre>
<p><strong>Example.</strong> The following Tamarin theory specifies a simple one-message protocol. Agent <code>A</code> sends a message encrypted with agent <code>B</code>'s public key to <code>B</code>. Both agents claim secrecy of a message, but only agent <code>A</code>'s claim is true. To distinguish between the two claims we add the action facts <code>Role('A')</code> (respectively <code>Role('B')</code>) to the rule modeling role <code>A</code> (respectively to the rule for role <code>B</code>). We then specify two secrecy lemmas, one for each role.</p>
<pre class="tamarin"><code>theory secrecy_asym_enc
begin

builtins: asymmetric-encryption

/* We formalize the following protocol:

    1. A -&gt; B: {A,na}pk(B)

*/

// Public key infrastructure
rule Register_pk:
  [ Fr(~ltkX) ]
  --&gt;
  [ !Ltk($X, ~ltkX)
  , !Pk($X, pk(~ltkX))
  , Out(pk(~ltkX))
  ] 

// Compromising an agent&#39;s long-term key
rule Reveal_ltk:
  [ !Ltk($X, ltkX) ] --[ Reveal($X) ]-&gt; [ Out(ltkX) ]

// Role A sends first message
rule A_1_send:
  [ Fr(~na)
  , !Ltk($A, ltkA)
  , !Pk($B, pkB)
  ]
--[ Send($A, aenc(&lt;$A, ~na&gt;, pkB)) 
  , Secret(~na), Honest($A), Honest($B), Role(&#39;A&#39;)
  ]-&gt;
  [ St_A_1($A, ltkA, pkB, $B, ~na) 
  , Out(aenc(&lt;$A, ~na&gt;, pkB))
  ]

// Role B receives first message
rule B_1_receive:
  [ !Ltk($B, ltkB)
  , In(aenc(&lt;$A, na&gt;,pk(ltkB)))
  ]
--[ Recv($B, aenc(&lt;$A, na&gt;, pk(ltkB)))
  , Secret(na), Honest($B), Honest($A), Role(&#39;B&#39;)
  ]-&gt;
  [ St_B_1($B, ltkB, $A, na)
  ]

lemma executable:
  exists-trace
    &quot;Ex A B m #i #j. Send(A,m)@i &amp; Recv(B,m) @j&quot;

lemma secret_A:
  all-traces
    &quot;All n #i. Secret(n) @i &amp; Role(&#39;A&#39;) @i ==&gt; (not (Ex #j. K(n)@j)) | (Ex B #j. Reveal(B)@j &amp; Honest(B)@i)&quot;

lemma secret_B:
  all-traces
    &quot;All n #i. Secret(n) @i &amp; Role(&#39;B&#39;) @i ==&gt; (not (Ex #j. K(n)@j)) | (Ex B #j. Reveal(B)@j &amp; Honest(B)@i)&quot;


end</code></pre>
<p>In the above example the lemma <code>secret_A</code> holds as the initiator generated the fresh value, while the responder has no guarantees, i.e., lemma <code>secret_B</code> yields an attack.</p>
<h3 id="sec:message-authentication">Authentication</h3>
<p>In this section we show how to specify a simple message authentication property. For specifications of the properties in Lowe's hierarchy of authentication specifications <span class="citation">(Lowe 1997)</span> see the Section <a href="#sec:elsewhere">Protocol and Standard Security Property Specification Templates</a>.</p>
<p>We specify the following <em>message authentication</em> property: If an agent <code>a</code> believes that a message <code>m</code> was sent by an agent <code>b</code>, then <code>m</code> was indeed sent by <code>b</code>. To specify <code>a</code>'s belief we label an appropriate rule in <code>a</code>'s role specification with the action <code>Authentic(b,m)</code>. The following lemma defines the set of traces that satisfy the message authentication property.</p>
<pre><code>lemma message_authentication: 
    &quot;All b m #j. Authentic(b,m) @j ==&gt; Ex #i. Send(b,m) @i &amp;i&lt;j&quot;</code></pre>
<p>A simple message authentication example is the following one-message protocol. Agent <code>A</code> sends a signed message to agent <code>B</code>. We model the signature using asymmetric encryption. A better model is shown in the section on Restrictions.</p>
<pre class="tamarin"><code>theory auth_signing_simple
begin

builtins: asymmetric-encryption

/* We formalize the following protocol:

    1. A -&gt; B: {A,na}sk(A)

*/

// Public key infrastructure
rule Register_pk:
  [ Fr(~ltkX) ]
  --&gt;
  [ !Ltk($X, ~ltkX)
  , !Pk($X, pk(~ltkX))
  , Out(pk(~ltkX)) 
  ] 

// Role A sends first message
rule A_1_send:
  [ Fr(~na)
  , !Ltk($A, ltkA)
  ]
--[ Send($A, &lt;$A, ~na&gt;) 
  ]-&gt;
  [ St_A_1($A, ltkA, ~na) 
  , Out(aenc(&lt;$A, ~na&gt;,ltkA))
  ]

// Role B receives first message
rule B_1_receive:
  [ !Pk($A, pk(skA))
  , In(aenc(&lt;$A, na&gt;,skA))
  ]
--[ Recv($B, &lt;$A, na&gt;)
  , Authentic($A,&lt;$A, na&gt;), Honest($B), Honest($A)
  ]-&gt;
  [ St_B_1($B, pk(skA), $A, &lt;$A, na&gt;)
  ]

lemma executable:
  exists-trace
    &quot;Ex A B m #i #j. Send(A,m)@i &amp; Recv(B,m) @j&quot;

lemma message_authentication: 
    &quot;All b m #i. Authentic(b,m) @i
     ==&gt; (Ex #j. Send(b,m) @j &amp; j&lt;i)&quot;

end</code></pre>
<h2 id="observational-equivalence">Observational Equivalence</h2>
<p>All the previous properties are trace properties, i.e., properties that are defined on each trace independently. For example, the definition of secrecy required that there is no trace where the adversary could compute the secret without having previously corrupted the agent.</p>
<p>In contrast, Observational Equivalence properties reason about two systems (for example two instances of a protocol), by showing that an intruder cannot distinguish these two systems. This can be used to express privacy-type properties, or cryptographic indistinguishability properties.</p>
<p>For example, a simple definition of privacy for voting requires that an adversary cannot distinguish two instances of a voting protocol where two voters swap votes. That is, in the first instance, voter <code>A</code> votes for candidate <code>a</code> and voter <code>B</code> votes for <code>b</code>, and in the second instance voter <code>A</code> votes for candidate <code>b</code> and voter <code>B</code> votes for <code>a</code>. If the intruder cannot tell both instances apart, he does not know which voter votes for which candidate, even though he might learn the result, i.e., that there is one vote for a and one for b.</p>
<p>Tamarin can prove such properties for two systems that only differ in terms using the <code>diff( , )</code> operator. Consider the following toy example, where one creates a public key, two fresh values <code>~a</code> and <code>~b</code>, and publishes <code>~a</code>. Then one encrypts either <code>~a</code> or <code>~b</code> (modeled using the <code>diff</code> operator) and sends out the ciphertext:</p>
<pre class="tamarin"><code>// Generate a public key and output it
// Choose two fresh values and reveal one of it
// Encrypt either the first or the second fresh value
rule Example:
    [ Fr(~ltk)
    , Fr(~a)
    , Fr(~b) ]
  --[ Secret( ~b ) ]-&gt;
    [ Out( pk(~ltk) )
    , Out( ~a )
    , Out( aenc( diff(~a,~b), pk(~ltk) ) )
    ]</code></pre>
<p>In this example, the intruder cannot compute <code>~b</code> as formalized by the following lemma:</p>
<pre class="tamarin"><code>lemma B_is_secret:
  &quot; /* The intruder cannot know ~b: */
    All B #i. (
      /* ~b is claimed secret implies */
      Secret(B) @ #i ==&gt;
      /* the adversary does not know &#39;~b&#39; */
      not( Ex #j. K(B) @ #j )
    )</code></pre>
<p>However, he can know whether in the last message <code>~a</code> or <code>~b</code> was encrypted by simply taking the output <code>~a</code>, encrypting it with the public key and comparing it to the published ciphertext. This is captured using observational equivalence.</p>
<p>To see how this works, we need to start Tamarin in observational equivalence mode by adding a <code>--diff</code> to the command:</p>
<pre><code>tamarin-prover interactive --diff ObservationalEquivalenceExample.spthy</code></pre>
<p>Now point your browser to <a href="http://localhost:3001" class="uri">http://localhost:3001</a>. After clicking on the theory <code>ObservationalEquivalenceExample</code>, you should see the following.</p>
<p><img src="../images/tamarin-obseq-overview.jpg" title="Observational Equivalence Overview" alt="Observational Equivalence Overview" style="width:100.0%" /><br />
There are multiple differences to the 'normal' trace mode.</p>
<p>First, there is a new option <code>Diff Rules</code>, which will simply present the rewrite rules from the <code>.spthy</code> file. (See image below.)</p>
<p>Second, all the other points (Message Theory, Multiset Rewrite Rules, Raw/Refined Sources) have been quadruplicated. The reason for this is that any input file with the <code>diff</code> operator actually specifies two models: one model where each instance of <code>diff(x,y)</code> is replaced with <code>x</code> (the <em>left hand side</em>, or LHS for short), and one model where each instance of <code>diff(x,y)</code> is replaced with <code>y</code> (the <em>right hand side</em>, or RHS for short). Moreover, as the observational equivalence mode requires different precomputations, each of the two models is treated twice. For example, the point <code>RHS: Raw sources [Diff]</code> gives the raw sources for the RHS interpretation of the model in observational equivalence mode, whereas <code>LHS: Raw sources</code> gives the raw sources for the LHS interpretation of the model in the 'trace' mode.</p>
<p>Third, all lemmas have been duplicated: the lemma <code>B_is_secret</code> exists once on the left hand side (marked using <code>[left]</code>) and once on the right hand side (marked using <code>[right]</code>), as both models can differ and thus the lemma needs to be proven on both sides.</p>
<p>Finally, there is a new lemma <code>Observational_equivalence</code>, added automatically by Tamarin (so no need to define it in the <code>.spthy</code> input file). By proving this lemma we can prove observational equivalence between the LHS and RHS models.</p>
<p>In the <code>Diff Rules</code>, we have the rules as written in the input file:</p>
<p><img src="../images/tamarin-obseq-diff-rules.jpg" title="Observational Equivalence Diff Rules" alt="Observational Equivalence Diff Rules" style="width:100.0%" /><br />
If we click on <code>LHS: Multiset rewriting rules</code>, we get the LHS interpretation of the rules (here <code>diff(~a, ~b)</code> was replaced by <code>~a</code>):</p>
<p><img src="../images/tamarin-obseq-lhs-rules.jpg" title="Observational Equivalence LHS Rules" alt="Observational Equivalence LHS Rules" style="width:100.0%" /><br />
If we click on <code>RHS: Multiset rewriting rules</code>, we get the RHS interpretation of the rules (here <code>diff(~a, ~b)</code> was replaced by <code>~b</code>):</p>
<p><img src="../images/tamarin-obseq-rhs-rules.jpg" title="Observational Equivalence RHS Rules" alt="Observational Equivalence RHS Rules" style="width:100.0%" /><br />
We can easily prove the <code>B_is_secret</code> lemma on both sides:</p>
<p><img src="../images/tamarin-obseq-lemmas.jpg" title="Observational Equivalence Lemmas" alt="Observational Equivalence Lemmas" style="width:100.0%" /><br />
To start proving observational equivalence, we only have the proof step <code>1.  rule-equivalence</code>. This generates multiple subcases:</p>
<p><img src="../images/tamarin-obseq-lemma-step1.jpg" title="Proving the Observational Equivalence Lemma" alt="Proving the Observational Equivalence Lemma" style="width:100.0%" /><br />
Essentially, there is a subcase per protocol rule, and there are also cases for several adversary rules. The idea of the proof is to show that whenever a rule can be executed on either the LHS or RHS, it can also be executed on the other side. Thus, no matter what the adversary does, he will always see 'equivalent' executions. To prove this, Tamarin computes for each rule all possible executions on both sides, and verifies whether an 'equivalent' execution exists on the other side. If we continue our proof by clicking on <code>backward-search</code>, Tamarin generates two sub-cases, one for each side. For each side, Tamarin will continue by constructing all possible executions of this rule.</p>
<p><img src="../images/tamarin-obseq-lemma-step2.jpg" title="Proving the Observational Equivalence Lemma" alt="Proving the Observational Equivalence Lemma" style="width:100.0%" /><br />
During this search, Tamarin can encounter executions that can be 'mirrored' on the other side, for example the following execution where the published key is successfully compared to itself:</p>
<p><img src="../images/tamarin-obseq-lemma-mirrored.jpg" title="Proving the Observational Equivalence Lemma: Mirrored" alt="Proving the Observational Equivalence Lemma: Mirrored" style="width:100.0%" /><br />
Or, Tamarin can encounter executions that do not map to the other side. For example the following execution on the LHS that encrypts <code>~a</code> using the public key and successfully compares the result to the published ciphertext, is not possible on the RHS (as there the ciphertext contains <code>~b</code>). Such an execution corresponds to a potential attack, and thus invalidates the &quot;Observational_equivalence&quot; lemma.</p>
<p><img src="../images/tamarin-obseq-lemma-attack.jpg" title="Proving the Observational Equivalence Lemma: Attack" alt="Proving the Observational Equivalence Lemma: Attack" style="width:100.0%" /><br />
Note that Tamarin needs to potentially consider numerous possible executions, which can result in long proof times or even non-termination. If possible it tries not to resolve parts of the execution that are irrelevant, but this is not always sufficient.</p>
<h2 id="restrictions">Restrictions</h2>
<p>Restrictions restrict the set of traces to be considered in the protocol analysis. They can be used for purposes ranging from modeling branching behavior of protocols to the verification of signatures. We give a brief example of the latter. Consider the simple message authentication protocol, where an agent <code>A</code> sends a signed message to an agent <code>B</code>. We use Tamarin's built-in equational <a href="004_cryptographic-messages.html#sec:builtin-theories">theory for signing</a>.</p>
<pre class="tamarin"><code>// Role A sends first message
rule A_1_send:
  let m = &lt;A, ~na&gt;
  in 
  [ Fr(~na)
  , !Ltk(A, ltkA)
  , !Pk(B, pkB)
  ]
--[ Send(A, m) 
  ]-&gt;
  [ St_A_1(A, ltkA, pkB, B, ~na) 
  , Out(&lt;m,sign(m,ltkA)&gt;)
  ]

// Role B receives first message
rule B_1_receive:
  [ !Ltk(B, ltkB)
  , !Pk(A, pkA)
  , In(&lt;m,sig&gt;)
  ]
--[ Recv(B, m)
  , Eq(verify(sig,m,pkA),true) 
  , Authentic(A,m), Honest(B), Honest(A)
  ]-&gt;
  [ St_B_1(B, ltkB, pkA, A, m)
  ]
</code></pre>
<p>In the above protocol, agent <code>B</code> verifies the signature <code>sig</code> on the received message <code>m</code>. We model this by considering only those traces of the protocol in which the application of the <code>verify</code> function to the received message equals the constant <code>true</code>. To this end, we specify the equality restriction</p>
<pre class="tamarin"><code>restriction Equality:
  &quot;All x y #i. Eq(x,y) @i ==&gt; x = y&quot;
</code></pre>
<p>The full protocol theory is given below.</p>
<pre class="tamarin"><code>theory auth_signing
begin

builtins: signing

/* We formalize the following protocol:

    1. A -&gt; B: {A,na}sk(A)

using Tamarin&#39;s builtin signing and verification functions.

*/

// Public key infrastructure
rule Register_pk:
  [ Fr(~ltkA) ]
  --&gt;
  [ !Ltk($A, ~ltkA)
  , !Pk($A, pk(~ltkA))
  , Out(pk(~ltkA)) 
  ] 

// Compromising an agent&#39;s long-term key
rule Reveal_ltk:
  [ !Ltk(A, ltkA) ] --[ Reveal(A) ]-&gt; [ Out(ltkA) ]

// Role A sends first message
rule A_1_send:
  let m = &lt;A, ~na&gt;
  in 
  [ Fr(~na)
  , !Ltk(A, ltkA)
  , !Pk(B, pkB)
  ]
--[ Send(A, m) 
  ]-&gt;
  [ St_A_1(A, ltkA, pkB, B, ~na) 
  , Out(&lt;m,sign(m,ltkA)&gt;)
  ]

// Role B receives first message
rule B_1_receive:
  [ !Ltk(B, ltkB)
  , !Pk(A, pkA)
  , In(&lt;m,sig&gt;)
  ]
--[ Recv(B, m)
  , Eq(verify(sig,m,pkA),true) 
  , Authentic(A,m), Honest(B), Honest(A)
  ]-&gt;
  [ St_B_1(B, ltkB, pkA, A, m)
  ]

restriction Equality:
  &quot;All x y #i. Eq(x,y) @i ==&gt; x = y&quot;

lemma executable:
  exists-trace
    &quot;Ex A B m #i #j. Send(A,m)@i &amp; Recv(B,m) @j&quot;

lemma message_authentication: 
    &quot;All b m #i. Authentic(b,m) @i
     ==&gt; (Ex #j. Send(b,m) @j &amp; j&lt;i)
         | (Ex B #r. Reveal(B)@r &amp; Honest(B) @i &amp; r &lt; i)&quot;

end</code></pre>
<p>Note that restrictions can also be used to verify observational equivalence properties. As there are no user-specifiable lemmas for observational equivalence, restrictions can be used to remove state space, which essentially removes degenerate cases.</p>
<!-- Finally, one can use also use restrictions to simplify the writing of lemmas. -->
<h2 id="common-restrictions">Common restrictions</h2>
<p>Here is a list of common restrictions. Do note that you need to add the appropriate action facts to your rules for these restrictions to have impact.</p>
<h3 id="unique">Unique</h3>
<p>First, let us show a restriction forcing an action (with a particular value) to be unique:</p>
<pre><code>restriction unique:
  &quot;All x #i #j. UniqueFact(x) @#i &amp; UniqueFact(x) @#j ==&gt; #i = #j&quot;</code></pre>
<p>We call the action <code>UniqueFact</code> and give it one argument. If it appears on the trace twice, it actually is only once, as the two time points are identified.</p>
<h3 id="equality">Equality</h3>
<p>Next, let us consider an equality restriction. This is useful if you do not want to use pattern-matching explicitly, but maybe want to ensure that the decryption of an encrypted value is the original value, assuming correct keys. The restriction looks like this:</p>
<pre><code>restriction Equality:
  &quot;All x y #i. Eq(x,y) @#i ==&gt; x = y&quot;</code></pre>
<p>which means that all instances of the <code>Eq</code> action on the trace have the same value as both its arguments.</p>
<h3 id="inequality">Inequality</h3>
<p>Now, let us consider an inequality restriction, which ensures that the two arguments of <code>Neq</code> are different:</p>
<pre><code>restriction Inequality:
  &quot;All x #i. Neq(x,x) @ #i ==&gt; F&quot;</code></pre>
<p>This is very useful to ensure that certain arguments are different.</p>
<h3 id="onlyonce">OnlyOnce</h3>
<p>If you have a rule that should only be executed once, put <code>OnlyOnce()</code> as an action fact for that rule and add this restriction:</p>
<pre><code>restriction OnlyOnce:
  &quot;All #i #j. OnlyOnce()@#i &amp; OnlyOnce()@#j ==&gt; #i = #j&quot;</code></pre>
<p>Then that rule can only be executed once. Note that if you have multiple rules that all have this action fact, at most one of them can be executed a single time.</p>
<p>A similar construction can be used to limit multiple occurrences of an action for specific instantiations of variables, by adding these as arguments to the action. For example, one could put <code>OnlyOnceV('Initiator')</code> in a rule creating an initiator process, and <code>OnlyOnceV('Responder')</code> in the rule for the responder. If used with the following restriction, this would then yield the expected result of at most one initiator and at most one responder:</p>
<pre><code>restriction OnlyOnceV:
  &quot;All #i #j x. OnlyOnceV(x)@#i &amp; OnlyOnceV(x)@#j ==&gt; #i = #j&quot;</code></pre>
<h3 id="less-than">Less than</h3>
<p>If we use the <code>multiset</code> built-in we can construct numbers as &quot;1+1+...+1&quot;, and have a restriction enforcing that one number is less than another, say <code>LessThan</code>:</p>
<pre><code>restriction LessThan:
  &quot;All x y #i. LessThan(x,y)@#i ==&gt; Ex z. x + z = y&quot;</code></pre>
<p>You would then add the <code>LessThan</code> action fact to a rule where you want to enforce that a counter has strictly increased.</p>
<p>Similarly you can use a <code>GreaterThan</code> where we want <code>x</code> to be strictly larger than <code>y</code>:</p>
<pre><code>restriction GreaterThan:
  &quot;All x y #i. GreaterThan(x,y)@#i ==&gt; Ex z. x = y + z&quot;</code></pre>
<h2 id="lemma-annotations">Lemma Annotations</h2>
<p>Tamarin supports a number of annotations to its lemmas, which change their meaning. Any combination of them is allowed. We explain them in this section. The usage is that any annotation goes into square brackets after the lemma name, i.e., for a lemma called &quot;Name&quot; and the added annotations &quot;Annotation1&quot; and &quot;Annotation2&quot;, this looks like so:</p>
<pre><code>lemma Name [Annotation1,Annotation2]:</code></pre>
<h3 id="sources"><code>sources</code></h3>
<p>To declare a lemma as a source lemma, we use the annotation <code>sources</code>:</p>
<pre><code>lemma example [sources]:
  &quot;...&quot;</code></pre>
<p>This means a number of things:</p>
<ul>
<li>The lemma's verification will use induction.</li>
<li>The lemma will be verified using the <code>Raw sources</code>.</li>
<li>The lemma will be used to generate the <code>Refined sources</code>, which are used for verification of all non-<code>sources</code> lemmas.</li>
</ul>
<p>Source lemmas are necessary whenever the analysis reports <code>partial deconstructions left</code> in the <code>Raw sources</code>. See section on <a href="007_precomputation.html#sec:openchains">Open chains</a> for details on this.</p>
<p>All <code>sources</code> lemmas are used only for the case distinctions and do not benefit from other lemmas being marked as <code>reuse</code>.</p>
<h3 id="use_induction"><code>use_induction</code></h3>
<p>As you have seen before, the first choice in any proof is whether to use simplification (the default) or induction. If you know that a lemma will require induction, you just annotate it with <code>use_induction</code>, which will make it use induction instead of simplification.</p>
<h3 id="reuse"><code>reuse</code></h3>
<p>A lemma marked <code>reuse</code> will be used in the proofs of all lemmas syntactically following it (except <code>sources</code> lemmas as above). This includes other <code>reuse</code> lemmas that can transitively depend on each other.</p>
<h3 id="hide_lemmal"><code>hide_lemma=L</code></h3>
<p>It can sometimes be helpful to have lemmas that are used only for the proofs of other lemmas. For example, assume 3 lemmas, called <code>A</code>, <code>B</code>, and <code>C</code>. They appear in that order, and <code>A</code> and <code>B</code> are marked reuse. Then, during the proof of <code>C</code> both <code>A</code> and <code>B</code> are reused, but sometimes you might only want to use <code>B</code>, but the proof of <code>B</code> needs <code>A</code>. The solution then is to hide the lemma <code>A</code> in <code>C</code>:</p>
<pre><code>lemma A [reuse]:
  ...

lemma B [reuse]:
  ...

lemma C [hide_lemma=A]:
  ...</code></pre>
<p>This way, <code>C</code> uses <code>B</code> which in turn uses <code>A</code>, but <code>C</code> does not use <code>A</code> directly.</p>
<h3 id="left-and-right"><code>left</code> and <code>right</code></h3>
<p>In the observational equivalence mode you have two protocols, the left instantiation of the <em>diff-terms</em> and their right instantiation. If you want to consider a lemma only on the left or right instantiation you annotate it with <code>left</code>, respectively <code>right</code>. If you annotate a lemma with <code>[left,right]</code> then both lemmas get generated, just as if you did not annotate it with either of <code>left</code> or <code>right</code>.</p>
<h2 id="sec:elsewhere">Protocol and Standard Security Property Specification Templates</h2>
<p>In this section we provide templates for specifying protocols and standard security properties in a unified manner.</p>
<h3 id="protocol-rules">Protocol Rules</h3>
<p>A protocol specifies two or more roles. For each role we specify an initialization rule that generates a fresh run identifier <code>id</code> (to distinguish parallel protocol runs of an agent) and sets up an agent's initial knowledge including long term keys, private keys, shared keys, and other agent's public keys. We label such a rule with the action fact <code>Create(A,id)</code>, where <code>A</code> is the agent name (a public constant) and <code>id</code> the run identifier and the action fact <code>Role('A')</code>, where <code>'A'</code> is a public constant string. An example of this is the following initialization rule:</p>
<pre class="tamarin"><code>// Initialize Role A
rule Init_A:
  [ Fr(~id)
  , !Ltk(A, ltkA)
  , !Pk(B, pkB)
  ]
--[ Create(A, ~id), Role(&#39;A&#39;) ]-&gt;
  [ St_A_1(A, ~id, ltkA, pkB, B)
  ]
</code></pre>
<p>The pre-distributed key infrastructure is modeled with a dedicated rule that may be accompanied by a key compromise rule. The latter is to model compromised agents and is labeled with a <code>Reveal(A)</code> action fact, where <code>A</code> is the public constant denoting the compromised agent. For instance, a public key infrastructure is modeled with the following two rules:</p>
<pre class="tamarin"><code>// Public key infrastructure
rule Register_pk:
  [ Fr(~ltkA) ]
  --&gt;
  [ !Ltk($A, ~ltkA)
  , !Pk($A, pk(~ltkA))
  , Out(pk(~ltkA)) 
  ] 

rule Reveal_ltk:
  [ !Ltk(A, ltkA) ] --[ Reveal(A) ]-&gt; [ Out(ltkA) ]
</code></pre>
<h3 id="secrecy-1">Secrecy</h3>
<p>We use the <code>Secret(x)</code> action fact to indicate that the message <code>x</code> is supposed to be secret. The simple secrecy property <code>&quot;All x #i. Secret(x) @i ==&gt; not (Ex #j. K(x)@j)&quot;</code> may not be satisfiable when agents' keys are compromised. We call an agent whose keys are not compromised an <em>honest</em> agent. We indicate assumptions on honest agents by labeling the same rule that the <code>Secret</code> action fact appears in with an <code>Honest(B)</code> action fact, where <code>B</code> is the agent name that is assumed to be honest. For instance, in the following rule the agent in role <code>'A'</code> is sending a message, where the nonce <code>~na</code> is supposed to be secret assuming that both agents <code>A</code> and <code>B</code> are honest.</p>
<pre class="tamarin"><code>// Role A sends first message
rule A_1_send:
  [ St_A_1(A, ~id, ltkA, pkB, B) 
  , Fr(~na)
  ]
--[ Send(A, aenc{A, ~na}pkB) 
  , Secret(~na), Honest(A), Honest(B), Role(&#39;A&#39;)
  ]-&gt;
  [ St_A_2(A, ~id, ltkA, pkB, B, ~na) 
  , Out(aenc{A, ~na}pkB)
  ]
</code></pre>
<p>We then specify the property that a message <code>x</code> is secret as long as agents assumed to be honest have not been compromised as follows</p>
<pre><code>lemma secrecy:
  &quot;All x #i. 
    Secret(x) @i ==&gt; 
    not (Ex #j. K(x)@j)
        | (Ex B #r. Reveal(B)@r &amp; Honest(B) @i)&quot;</code></pre>
<p>The lemma states that whenever a secret action <code>Secret(x)</code> occurs at timepoint <code>i</code>, the adversary does not know <code>x</code> or an agent claimed to be honest at time point <code>i</code> has been compromised at a timepoint <code>r</code>.</p>
<p>A stronger secrecy property is <em>perfect forward secrecy</em>. It requires that messages labeled with a <code>Secret</code> action before a compromise remain secret.</p>
<pre><code>lemma secrecy_PFS:
  &quot;All x #i. 
    Secret(x) @i ==&gt; 
    not (Ex #j. K(x)@j)
        | (Ex B #r. Reveal(B)@r &amp; Honest(B) @i &amp; r &lt; i)&quot;</code></pre>
<p><strong>Example.</strong> The following Tamarin theory specifies a simple one-message protocol. Agent <code>A</code> sends a message encrypted with agent <code>B</code>'s public key to <code>B</code>. Both agents claim secrecy of a message, but only agent <code>A</code>'s claim is true. To distinguish between the two claims we add the action facts <code>Role('A')</code> and <code>Role('B')</code> for role <code>A</code> and <code>B</code>, respectively and specify two secrecy lemmas, one for each role.</p>
<p>The perfect forward secrecy claim does not hold for agent <code>A</code>. We show this by negating the perfect forward secrecy property and stating an exists-trace lemma.</p>
<pre class="tamarin"><code>theory secrecy_template
begin

builtins: asymmetric-encryption

/* We formalize the following protocol:

    1. A -&gt; B: {A,na}pk(B)

*/

// Public key infrastructure
rule Register_pk:
  [ Fr(~ltkA) ]
  --&gt;
  [ !Ltk($A, ~ltkA)
  , !Pk($A, pk(~ltkA))
  , Out(pk(~ltkA)) 
  ] 

rule Reveal_ltk:
  [ !Ltk(A, ltkA) ] --[ Reveal(A) ]-&gt; [ Out(ltkA) ]

// Initialize Role A
rule Init_A:
  [ Fr(~id)
  , !Ltk(A, ltkA)
  , !Pk(B, pkB)
  ]
--[ Create(A, ~id), Role(&#39;A&#39;) ]-&gt;
  [ St_A_1(A, ~id, ltkA, pkB, B)
  ]

// Initialize Role B
rule Init_B:
  [ Fr(~id)
  , !Ltk(B, ltkB)
  , !Pk(A, pkA)
  ]
--[ Create(B, ~id), Role(&#39;B&#39;) ]-&gt;
  [ St_B_1(B, ~id, ltkB, pkA, A)
  ]

// Role A sends first message
rule A_1_send:
  [ St_A_1(A, ~id, ltkA, pkB, B) 
  , Fr(~na)
  ]
--[ Send(A, aenc{A, ~na}pkB) 
  , Secret(~na), Honest(A), Honest(B), Role(&#39;A&#39;)
  ]-&gt;
  [ St_A_2(A, ~id, ltkA, pkB, B, ~na) 
  , Out(aenc{A, ~na}pkB)
  ]

// Role B receives first message
rule B_1_receive:
  [ St_B_1(B, ~id, ltkB, pkA, A)
  , In(aenc{A, na}pkB)
  ]
--[ Recv(B, aenc{A, na}pkB) 
  , Secret(na), Honest(B), Honest(A), Role(&#39;B&#39;)
  ]-&gt;
  [ St_B_2(B, ~id, ltkB, pkA, A, na)
  ]

lemma executable:
  exists-trace
    &quot;Ex A B m #i #j. Send(A,m)@i &amp; Recv(B,m) @j&quot;

lemma secret_A:
    &quot;All n #i. Secret(n) @i &amp; Role(&#39;A&#39;) @i ==&gt; 
     (not (Ex #j. K(n)@j)) | (Ex X #j. Reveal(X)@j &amp; Honest(X)@i)&quot;

lemma secret_B:
    &quot;All n #i. Secret(n) @i &amp; Role(&#39;B&#39;) @i ==&gt; 
     (not (Ex #j. K(n)@j)) | (Ex X #j. Reveal(X)@j &amp; Honest(X)@i)&quot;

lemma secrecy_PFS_A:
  exists-trace
  &quot;not All x #i. 
    Secret(x) @i &amp; Role(&#39;A&#39;) @i ==&gt; 
    not (Ex #j. K(x)@j)
        | (Ex B #r. Reveal(B)@r &amp; Honest(B) @i &amp; r &lt; i)&quot;

end</code></pre>
<h3 id="authentication">Authentication</h3>
<p>In this section we show how to formalize the entity authentication properties of Lowe's hierarchy of authentication specifications <span class="citation">(Lowe 1997)</span> for two-party protocols.</p>
<p>All the properties defined below concern the authentication of an agent in role <code>'B'</code> to an agent in role <code>'A'</code>. To analyze a protocol with respect to these properties we label an appropriate rule in role <code>A</code> with a <code>Commit(a,b,&lt;'A','B',t&gt;)</code> action and in role <code>B</code> with the <code>Running(b,a,&lt;'A','B',t&gt;)</code> action. Here <code>a</code> and <code>b</code> are the agent names (public constants) of roles <code>A</code> and <code>B</code>, respectively and <code>t</code> is a term.</p>
<ol style="list-style-type: decimal">
<li>Aliveness</li>
</ol>
<p>A protocol guarantees to an agent <code>a</code> in role <code>A</code> <em>aliveness</em> of another agent <code>b</code> if, whenever <code>a</code> completes a run of the protocol, apparently with <code>b</code> in role <code>B</code>, then <code>b</code> has previously been running the protocol.</p>
<pre><code>lemma aliveness:
   &quot;All a b t #i. 
     Commit(a,b,t)@i 
     ==&gt;  (Ex id #j. Create(b,id) @ j)
          | (Ex C #r. Reveal(C) @ r &amp; Honest(C) @ i)&quot;</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Weak agreement</li>
</ol>
<p>A protocol guarantees to an agent <code>a</code> in role <code>A</code> <em>weak agreement</em> with another agent <code>b</code> if, whenever agent <code>a</code> completes a run of the protocol, apparently with <code>b</code> in role <code>B</code>, then <code>b</code> has previously been running the protocol, apparently with <code>a</code>.</p>
<pre><code>lemma weak_agreement:
  &quot;All a b t1 #i. 
    Commit(a,b,t1) @i
    ==&gt; (Ex t2 #j. Running(b,a,t2) @j)
        | (Ex C #r. Reveal(C) @ r &amp; Honest(C) @ i)&quot;</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Non-injective agreement</li>
</ol>
<p>A protocol guarantees to an agent <code>a</code> in role <code>A</code> <em>non-injective agreement</em> with an agent <code>b</code> in role <code>B</code> on a message <code>t</code> if, whenever <code>a</code> completes a run of the protocol, apparently with <code>b</code> in role <code>B</code>, then <code>b</code> has previously been running the protocol, apparently with <code>a</code>, and <code>b</code> was acting in role <code>B</code> in his run, and the two principals agreed on the message <code>t</code>.</p>
<pre><code>lemma noninjective_agreement:
  &quot;All a b t #i. 
    Commit(a,b,t) @i
    ==&gt; (Ex #j. Running(b,a,t) @j)
        | (Ex C #r. Reveal(C) @ r &amp; Honest(C) @ i)&quot;</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>Injective agreement</li>
</ol>
<p>We next show the lemma to analyze <em>injective agreement</em>. A protocol guarantees to an agent <code>a</code> in role <code>A</code> injective agreement with an agent <code>b</code> in role <code>B</code> on a message <code>t</code> if, whenever <code>a</code> completes a run of the protocol, apparently with <code>b</code> in role <code>B</code>, then <code>b</code> has previously been running the protocol, apparently with <code>a</code>, and <code>b</code> was acting in role <code>B</code> in his run, and the two principals agreed on the message <code>t</code>. Additionally, there is a unique matching partner instance for each completed run of an agent, i.e., for each <code>Commit</code> by an agent there is a unique <code>Running</code> by the supposed partner.</p>
<pre><code>lemma injectiveagreement:
  &quot;All A B t #i. 
    Commit(A,B,t) @i
    ==&gt; (Ex #j. Running(B,A,t) @j 
        &amp; j &lt; i
        &amp; not (Ex A2 B2 #i2. Commit(A2,B2,t) @i2
                           &amp; not (#i2 = #i)))
              | (Ex C #r. Reveal(C)@r &amp; Honest(C) @i)&quot;</code></pre>
<p>The idea behind injective agreement is to prevent replay attacks. Therefore, new freshness will have to be involved in each run, meaning the term <code>t</code> must contain such a fresh value.</p>
<div id="refs" class="references">
<div id="ref-Lowe">
<p>Lowe, Gavin. 1997. “A Hierarchy of Authentication Specifications.” In <em>10th Computer Security Foundations Workshop (Csfw 1997), June 10-12, 1997, Rockport, Massachusetts, Usa</em>, 31–44. IEEE Computer Society. <a href="http://www.cs.ox.ac.uk/people/gavin.lowe/Security/Papers/authentication.ps" class="uri">http://www.cs.ox.ac.uk/people/gavin.lowe/Security/Papers/authentication.ps</a>.</p>
</div>
</div>
    </div>
  </div>
</body>
</html>
