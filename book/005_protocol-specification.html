<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tamarin Prover Manual</title>
    <link rel="stylesheet" type="text/css" href="book.css">
    <script src="book.js"></script>
    <link rel="stylesheet" href="styles/github.css">
<!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
          <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    </head>
<body class="tamarindoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
    <span class="sr-only">Toggle navigation</span>
    <span class="bar"></span>
    <span class="bar"></span>
    <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
  <ul class='chapter'>
<!-- <li><a href='000_prelims.html'                    ><b>0. </b>Preliminaries</a></li> -->
<li><a href='001_introduction.html'               ><b>1. </b> Introduction</a></li>
<li><a href='002_installation.html'               ><b>2. </b> Installation</a></li>
<li><a href='003_example.html'                    ><b>3. </b> First Example</a></li>
<li><a href='004_cryptographic-messages.html'     ><b>4. </b> Cryptographic Messages</a></li>
<li><a href='005_protocol-specification.html'     ><b>5. </b> Protocol Specification</a></li>
<li><a href='006_property-specification.html'     ><b>6. </b> Property Specification</a></li>
<li><a href='007_precomputation.html'             ><b>7. </b> Precomputation</a></li>
<li><a href='008_modeling-issues.html'            ><b>8. </b> Modeling Issues</a></li>
<li><a href='009_advanced-features.html'          ><b>9. </b> Advanced Features</a></li>
<li><a href='010_case-studies.html'               ><b>10.</b> Case Studies</a></li>
<li><a href='011_toolchains.html'                 ><b>11.</b> Toolchains</a></li>
<li><a href='012_limitations.html'                ><b>12.</b> Limitations</a></li>
<li><a href='013_contact-and-further-reading.html'><b>13.</b> Contact Information and Further Reading</a></li>
<li><a href='014_syntax_description.html'         ><b>14.</b> Syntax Description</a></li>
  </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
<p class="halfbreak">
</p>
<h1 id="sec:model-specification">Model Specification</h1>
<p>In this section, we now provide an informal description of the underlying model. The full details of this model can be found in <span class="citation">(Schmidt 2012)</span>.</p>
<p>Tamarin models are specified using three main ingredients:</p>
<ol style="list-style-type: decimal">
<li>Rules</li>
<li>Facts</li>
<li>Terms</li>
</ol>
<p>We have already seen the definition of terms in the previous section. Here we will discuss facts and rules, and illustrate their use with respect to the Naxos protocol, displayed below.</p>
<p><img src="../images/naxos.png" alt="The Naxos protocol" style="width:80.0%" /><br />
<!-- **FIX Cas: Picture should be updated and use vector graphics, ideally.**
--></p>
<p>In this protocol, each party <code>x</code> has a long-term private key <code>lkx</code> and a corresponding public key <code>pkx = 'g'^lkx</code>, where <code>'g'</code> is a generator of the Diffie-Hellman group. Because <code>'g'</code> can be public, we model it as a public constant. Two different hash functions <code>h1</code> and <code>h2</code> are used.</p>
<p>To start a session, the initiator <code>I</code> first creates a fresh nonce <code>eskI</code>, also known as <code>I</code>’s ephemeral (private) key. He then concatenates <code>eskI</code> with <code>I</code>’s long-term private key <code>lkI</code>, hashes the result using the hash function <code>h1</code>, and sends <code>'g'^h1(eskI ,lkI)</code> to the responder. The responder <code>R</code> stores the received value in a variable <code>X</code>, computes a similar value based on his own nonce <code>eskR</code> and long-term private key <code>lkR</code>, and sends the result to the initiator, who stores the received value in the variable <code>Y</code>. Finally, both parties compute a session key (<code>kI</code> and <code>kR</code>, respectively) whose computation includes their own long-term private keys, such that only the intended partner can compute the same key.</p>
<p>Note that the messages exchanged are not authenticated as the recipients cannot verify that the expected long-term key was used in the construction of the message. The authentication is implicit and only guaranteed through ownership of the correct key. Explicit authentication (e.g., the intended partner was recently alive or agrees on some values) is commonly achieved in authenticated key exchange protocols by adding a key-confirmation step, where the parties exchange a MAC of the exchanged messages that is keyed with (a variant of) the computed session key.</p>
<h2 id="sec:rules">Rules</h2>
<p>We use multiset rewriting to specify the concurrent execution of the protocol and the adversary. Multiset rewriting is a formalism that is commonly used to model concurrent systems since it naturally supports independent transitions.</p>
<p>A multiset rewriting system defines a transition system, where, in our case, the transitions will be labeled. The system's state is a multiset (bag) of facts. We will explain the types of facts and their use below.</p>
<p>A rewrite rule in Tamarin has a name and three parts, each of which is a sequence of facts: one for the rule's left-hand side, one labelling the transition (which we call 'action facts'), and one for the rule's right-hand side. For example:</p>
<pre><code>rule MyRule1:
  [ ] --[ L(&#39;x&#39;) ]-&gt; [ F(&#39;1&#39;,&#39;x&#39;), F(&#39;2&#39;,&#39;y&#39;) ]

rule MyRule2:
  [ F(u,v) ] --[ M(u,v) ]-&gt; [ H(u), G(&#39;3&#39;,h(v)) ]</code></pre>
<p>For now, we will ignore the action facts (<code>L(...)</code> and <code>M(...)</code>) and return to them when discussing properties in the next section. If a rule is not labelled by action facts, the arrow notation <code>--[ ]-&gt;</code> can be abbreviated to <code>--&gt;</code>.</p>
<p>The rule names are only used for referencing specific rules. They have no specific meaning and can be chosen arbitrarily, as long as each rule has a unique name.</p>
<h3 id="executions">Executions</h3>
<p>The initial state of the transition system is the empty multiset.</p>
<p>The rules define how the system can make a transition to a new state. A rule can be applied to a state if it can be instantiated such that its left hand side is contained in the current state. In this case, the left-hand side facts are removed from the state, and replaced by the instantiated right hand side.</p>
<p>For example, in the initial state, <code>MyRule1</code> can be instantiated repeatedly.</p>
<p>For any instantiation of <code>MyRule1</code>, this leads to follow-up state that contains <code>F('1','x')</code> and <code>F('2','y')</code>. <code>MyRule2</code> cannot be applied in the initial state since it contains no <code>F</code> facts. In the successor state, the rule <code>MyRule2</code> can now be applied twice. It can be instantiated either by <code>u</code> equal to <code>'1'</code> (with <code>v</code> equal to <code>'x'</code>) or to <code>'2'</code> (with <code>v</code> equal to <code>'y'</code>). Each of these instantiations leads to a new successor state.</p>
<h3 id="using-let-binding-in-rules-for-local-macros">Using 'let' binding in rules for local macros</h3>
<p>When modeling more complex protocols, a term may occur multiple times (possibly as a subterm) within the same rule. To make such specifications more readable, Tamarin offers support for <code>let ... in</code>, as in the following example:</p>
<pre><code>rule MyRuleName:
    let foo1 = h(bar)
        foo2 = &lt;&#39;bars&#39;, foo1&gt;
        ...
        var5 = pk(~x)
    in
    [ ... ] --[ ... ]-&gt; [ ... ]</code></pre>
<p>Such let-binding expressions can be used to specify local term macros within the context of a rule. Each macro should occur on a separate line and defines a substitution: the left-hand side of the <code>=</code> sign must be a variable and the right-hand side is an arbitrary term. The rule will be interpreted after substituting all variables occurring in the let by their right-hand sides. As the above example indicates, macros may use the left-hand sides of earlier defined macros.</p>
<h2 id="facts">Facts</h2>
<p>Facts are of the form <code>F(t1,...,tn)</code> for a fact symbol <code>F</code> and terms <code>ti</code>. They have a fixed arity (in this case <code>n</code>). Note that if a Tamarin model uses the same fact with two different arities, Tamarin will report an error.</p>
<p>There are three types of special facts built in to Tamarin. These are used to model interaction with the untrusted network and to model the generation of unique fresh (random) values.</p>
<dl>
<dt><code>In</code></dt>
<dd><p>This fact is used to model a party receiving a message from the untrusted network that is controlled by a Dolev-Yao adversary, and can only occur on the left-hand side of a rewrite rule.</p>
</dd>
<dt><code>Out</code></dt>
<dd><p>This fact is used to model a party sending a message to the untrusted network that is controlled by a Dolev-Yao adversary, and can only occur on the right-hand side of a rewrite rule.</p>
</dd>
<dt><code>Fr</code></dt>
<dd><p>This fact must be used when generating fresh (random) values, and can only occur on the left-hand side of a rewrite rule, where its argument is the fresh term. Tamarin's underlying execution model has a built-in rule for generating instances of <code>Fr(x)</code> facts, and also ensures that each instance produces a term (instantiating <code>x</code>) that is different from all others.</p>
</dd>
</dl>
<p>For the above three facts, Tamarin has built-in rules. In particular, there is a fresh rule that produces unique <code>Fr(...)</code> facts, and there is a set of rules for adversary knowledge derivation, which consume <code>Out(...)</code> facts and produce <code>In(...)</code> facts.</p>
<h3 id="linear-versus-persistent-facts">Linear versus persistent facts</h3>
<p>The facts mentioned above are called 'linear facts'. They are not only produced by rules, they also can be consumed by rules. Hence they might appear in one state but not in the next.</p>
<p>In contrast, some facts in our models will never be removed from the state once they are introduced. Modeling this using linear facts would require that every rule that has such a fact in the left-hand-side, also has an exact copy of this fact in the right-hand side. While there is no fundamental problem with this modeling in theory, it is inconvenient for the user and it also might lead Tamarin to explore rule instantiations that are irrelevant for tracing such facts in practice, which may even lead to non-termination.</p>
<p>For the above two reasons, we now introduce 'persistent facts', which are never removed from the state. We denote these facts by prefixing them with a bang (<code>!</code>).</p>
<p>Facts always start with an upper-case letter and need not be declared explicitly. If their name is prefixed with an exclamation mark <code>!</code>, then they are persistent. Otherwise, they are linear. Note that every fact name must be used consistently; i.e., it must always be used with the same arity, case, persistence, and multiplicity. Otherwise, Tamarin complains that the theory is not well-formed.</p>
<p>Comparing linear and persistent fact behaviour we note that if there is a persistent fact in some rule's premise, then Tamarin will consider all rules that produce this persistent fact in their conclusion as the source. Usually though, there are few such rules (most often just a single one), which simplifies the reasoning. For linear facts, particularly those that are used in many rules (and kept static), obviously there are many rules with the fact in their conclusion (all of them!). Thus, when looking for a source in any premise, all such rules need to be considered, which is clearly less efficient and non-termination-prone as mentioned above. Hence, when trying to model facts that are never consumed, the use of persistent facts is preferred.</p>
<h2 id="modeling-protocols">Modeling protocols</h2>
<p>There are several ways in which the execution of security protocols can be defined, e.g., as in <span class="citation">(Cremers and Mauw 2012)</span>. In Tamarin, there is no pre-defined protocol concept and the user is free to model them as she or he chooses. Below we give an example of how protocols can be modeled and discuss alternatives afterwards.</p>
<h3 id="public-key-infrastructure">Public-key infrastructure</h3>
<p>In the Tamarin model, there is no pre-defined notion of public key infrastructure (PKI). A pre-distributed PKI with asymmetric keys for each party can be modeled by a single rule that generates a key for a party. The party's identity and public/private keys are then stored as facts in the state, enabling protocol rules to retrieve them. For the public key, we commonly use the <code>Pk</code> fact, and for the corresponding long-term private key we use the <code>Ltk</code> fact. Since these facts will only be used by other rules to retrieve the keys, but never updated, we model them as persistent facts. We use the abstract function <code>pk(x)</code> to denote the public key corresponding to the private key <code>x</code>, leading to the following rule. Note that we also directly give all public keys to the attacker, modeled by the <code>Out</code> on the right-hand side.</p>
<pre><code>rule Generate_key_pair:
  [ Fr(~x) ] 
  --&gt; 
  [ !Pk($A,pk(~x))
  , Out(pk(~x))
  , !Ltk($A,~x)
  ]</code></pre>
<p>Some protocols, such as Naxos, rely on the algebraic properties of the key pairs. In many DH-based protocols, the public key is <span class="math inline">\(g^x\)</span> for the private key <span class="math inline">\(x\)</span>, which enables exploiting the commutativity of the exponents to establish keys. In this case, we specify the following rule instead.</p>
<pre><code>rule Generate_DH_key_pair:
  [ Fr(~x) ] 
  --&gt; 
  [ !Pk($A,&#39;g&#39;^~x)
  , Out(&#39;g&#39;^~x)
  , !Ltk($A,~x)
  ]</code></pre>
<h3 id="modeling-a-protocol-step">Modeling a protocol step</h3>
<p>Protocols describe the behavior of agents in the system. Agents can perform protocol steps, such as receiving a message and responding by sending a message, or starting a session.</p>
<h3 id="modeling-the-naxos-responder-role">Modeling the Naxos responder role</h3>
<p>We first model the responder role, which is simpler than the initiator role since it can be done in one rule.</p>
<p>The protocol uses a Diffie-Hellman exponentiation, and two hash functions <code>h1</code> and <code>h2</code>, which we must declare. We can model this using:</p>
<pre><code>builtins: diffie-hellman</code></pre>
<p>and</p>
<pre><code>functions: h1/1
functions: h2/1</code></pre>
<p>Without any further equations, a function declared in this fashion will behave as a one-way function.</p>
<p>Each time a responder thread of an agent <code>$R</code> receives a message, it will generate a fresh value <code>~eskR</code>, send a response message, and compute a key <code>kR</code>. We can model receiving a message by specifying an <code>In</code> fact on the left-hand side of a rule. To model the generation of a fresh value, we require it to be generated by the built-in fresh rule.</p>
<p>Finally, the rule depends on the actor's long-term private key, which we can obtain from the persistent fact generated by the <code>Generate_DH_key_pair</code> rule presented previously.</p>
<p>The response message is an exponentiation of <code>g</code> to the power of a computed hash function. Since the hash function is unary (arity one), if we want to invoke it on the concatenation of two messages, we model them as a pair <code>&lt;x,y&gt;</code> which will be used as the single argument of <code>h1</code>.</p>
<p>Thus, an initial formalization of this rule might be as follows:</p>
<pre><code>    rule NaxosR_attempt1:
            [
              In(X),
              Fr(~eskR),
              !Ltk($R, lkR)
            ]
            --&gt;
            [
              Out( &#39;g&#39;^h1(&lt; ~eskR, lkR &gt;) )
            ]</code></pre>
<p>However, the responder also computes a session key <code>kR</code>. Since the session key does not affect the sent or received messages, we can omit it from the left-hand side and the right-hand side of the rule. However, later we will want to make a statement about the session key in the security property. We therefore add the computed key to the actions:</p>
<pre><code>    rule NaxosR_attempt2:
            [ 
              In(X), 
              Fr(~eskR),
              !Ltk($R, lkR)
            ] 
            --[ SessionKey($R, kR ) ]-&gt;
            [ 
              Out( &#39;g&#39;^h1(&lt; ~eskR, lkR &gt;) ) 
            ]</code></pre>
<p>The computation of <code>kR</code> is not yet specified in the above. We could replace <code>kR</code> in the above rule by its full unfolding, but this would decrease readability. Instead, we use let binding to avoid duplication and reduce possible mismatches. Additionally, for the key computation we need the public key of the communication partner <code>$I</code>, which we bind to a unique thread identifier <code>~tid</code>; we use the resulting action fact to specify security properties, as we will see in the next section. This leads to:</p>
<pre><code>    rule NaxosR_attempt3:
      let 
          exR = h1(&lt; ~eskR, lkR &gt;)
          hkr = &#39;g&#39;^exR
          kR  = h2(&lt; pkI^exR, X^lkR, X^exR, $I, $R &gt;)
      in
       [
           In(X),
           Fr( ~eskR ),
           Fr( ~tid ),
           !Ltk($R, lkR),
           !Pk($I, pkI)
       ]
       --[ SessionKey( ~tid, $R, $I, kR ) ]-&gt;
       [
           Out( hkr )
       ]</code></pre>
<p>The above rule models the responder role accurately, and computes the appropriate key.</p>
<p>We note one further optimization that helps Tamarin's backwards search. In <code>NaxosR_attempt3</code>, the rule specifies that <code>lkR</code> might be instantiated with any term, hence also non-fresh terms. However, since the key generation rule is the only rule that produces <code>Ltk</code> facts, and it will always use a fresh value for the key, it is clear that in any reachable state of the system, <code>lkR</code> can only become instantiated by fresh values. We can therefore mark <code>lkR</code> as being of sort fresh, therefore replacing it by <code>~lkR</code>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<pre class="tamarin"><code>rule NaxosR:
  let 
      exR = h1(&lt; ~eskR, ~lkR &gt;)
      hkr = &#39;g&#39;^exR
      kR  = h2(&lt; pkI^exR, X^~lkR, X^exR, $I, $R &gt;)
  in
   [
       In(X),
       Fr( ~eskR ),
       Fr( ~tid ),
       !Ltk($R, ~lkR),
       !Pk($I, pkI)
   ]
   --[ SessionKey( ~tid, $R, $I, kR ) ]-&gt;
   [
       Out( hkr )
   ]</code></pre>
<p>The above rule suffices to model basic security properties, as we will see later.</p>
<h3 id="modeling-the-naxos-initiator-role">Modeling the Naxos initiator role</h3>
<p>The initiator role of the Naxos protocol consists of sending a message and waiting for the response. While the initiator is waiting for a response, other agents might also perform steps. We therefore model the initiator using two rules.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>The first rule models an agent starting the initiator role, generating a fresh value, and sending the appropriate message. As before, we use let binding to simplify the presentation and use <code>~lkI</code> instead of <code>lkI</code> since we know that <code>!Ltk</code> facts are only produced with a fresh value as the second argument.</p>
<pre><code>    rule NaxosI_1_attempt1:
      let exI = h1(&lt;~eskI, ~lkI &gt;)
          hkI = &#39;g&#39;^exI
      in
       [   Fr( ~eskI ),
           !Ltk( $I, ~lkI ) ]
       --&gt;
       [   Out( hkI ) ]</code></pre>
<h4 id="using-state-facts-to-model-progress">Using state facts to model progress</h4>
<p>After triggering the previous rule, an initiator will wait for the response message. We still need to model the second part, in which the response is received and the key is computed. To model the second part of the initiator rule, we must be able to specify that it was preceded by the first part and with specific parameters. Intuitively, we must store in the state of the transition system that there is an initiator thread that has performed the first send with specific parameters, so it can continue where it left off.</p>
<p>To model this, we introduce a new fact, which we often refer to as a <em>state fact</em>: a fact that indicates that a certain process or thread is at a specific point in its execution, effectively operating both as a program counter and as a container for the contents of the memory of the process or thread. Since there can be any number of initiators in parallel, we need to provide a unique handle for each of their state facts.</p>
<p>Below we provide an updated version of the initiator's first rule that produces a state fact <code>Init_1</code> and introduces a unique thread identifier <code>~tid</code> for each instance of the rule.</p>
<pre class="tamarin"><code>rule NaxosI_1:
  let exI = h1(&lt;~eskI, ~lkI &gt;)
      hkI = &#39;g&#39;^exI
  in
   [   Fr( ~eskI ),
       Fr( ~tid ),
       !Ltk( $I, ~lkI ) ]
   --&gt;
   [   Init_1( ~tid, $I, $R, ~lkI, ~eskI ),
       Out( hkI ) ]</code></pre>
<p>Note that the state fact has several parameters: the unique thread identifier <code>~tid</code><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, the agent identities <code>$I</code> and <code>$R</code>, and the actor's long-term private key <code>~lkI</code>, and the private exponent. This now enables us to specify the second initiator rule.</p>
<pre class="tamarin"><code>rule NaxosI_2:
  let
      exI = h1(&lt; ~eskI, ~lkI &gt;)
      kI  = h2(&lt; Y^~lkI, pkR^exI, Y^exI, $I, $R &gt;)
  in
   [   Init_1( ~tid, $I, $R, ~lkI , ~eskI),
       !Pk( $R, pkR ),
       In( Y ) ]
   --[ SessionKey( ~tid, $I, $R, kI ) ]-&gt;
  []</code></pre>
<p>This second rule requires receiving a message <code>Y</code> from the network but also that an initiator fact was previously generated. This rule then consumes this fact, and since there are no further steps in the protocol, does not need to output a similar fact. As the <code>Init_1</code> fact is instantiated with the same parameters, the second step will use the same agent identities and the exponent <code>exI</code> computed in the first step.</p>
<p>Thus, the complete example becomes:</p>
<pre class="tamarin"><code>theory Naxos
begin

builtins: diffie-hellman

functions: h1/1
functions: h2/1

rule Generate_DH_key_pair:
  [ Fr(~x) ] 
  --&gt; 
  [ !Pk($A,&#39;g&#39;^~x)
  , Out(&#39;g&#39;^~x)
  , !Ltk($A,~x)
  ]

rule NaxosR:
  let 
      exR = h1(&lt; ~eskR, ~lkR &gt;)
      hkr = &#39;g&#39;^exR
      kR  = h2(&lt; pkI^exR, X^~lkR, X^exR, $I, $R &gt;)
  in
   [
       In(X),
       Fr( ~eskR ),
       Fr( ~tid ),
       !Ltk($R, ~lkR),
       !Pk($I, pkI)
   ]
   --[ SessionKey( ~tid, $R, $I, kR ) ]-&gt;
   [
       Out( hkr )
   ]

rule NaxosI_1:
  let exI = h1(&lt;~eskI, ~lkI &gt;)
      hkI = &#39;g&#39;^exI
  in
   [   Fr( ~eskI ),
       Fr( ~tid ),
       !Ltk( $I, ~lkI ) ]
   --&gt;
   [   Init_1( ~tid, $I, $R, ~lkI, ~eskI ),
       Out( hkI ) ]

rule NaxosI_2:
  let
      exI = h1(&lt; ~eskI, ~lkI &gt;)
      kI  = h2(&lt; Y^~lkI, pkR^exI, Y^exI, $I, $R &gt;)
  in
   [   Init_1( ~tid, $I, $R, ~lkI , ~eskI),
       !Pk( $R, pkR ),
       In( Y ) ]
   --[ SessionKey( ~tid, $I, $R, kI ) ]-&gt;
  []

end</code></pre>
<p>Note that the protocol description only specifies a model, but not which properties it might satisfy. We discuss these in the next section.</p>
<!--
**FIX Cas: need to do either pattern matching or explicit construct/deconstruct;
not a big deal for naxos, but should pop up somewhere**
Alternative modeling approaches
-------------------------------

**FIX Cas: splitting send/receive, etc.**

**FIX Cas: pattern matching vs deconstructors**





TODO:
  * Example use-cases for variable annotations ($ ~), and any caveats that
    might come with them (like if incorrect ~ use can make things unsound)

  * An explanation/examples of the difference between K, KU, and KD, and when
    you would use each. (This should go in the next section)
-->
<div id="refs" class="references">
<div id="ref-opsem2012">
<p>Cremers, Cas, and Sjouke Mauw. 2012. <em>Operational Semantics and Verification of Security Protocols</em>. Springer-Verlag Berlin Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-540-78636-8">10.1007/978-3-540-78636-8</a>.</p>
</div>
<div id="ref-benediktthesis">
<p>Schmidt, Benedikt. 2012. “Formal Analysis of Key Exchange Protocols and Physical Protocols.” PhD thesis, ETH Zurich. <a href="http://dx.doi.org/10.3929/ethz-a-009898924" class="uri">http://dx.doi.org/10.3929/ethz-a-009898924</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note that in contrast, replacing <code>X</code> by <code>~X</code> would change the interpretation of the model, effectively restricting the instantiations of the rule to those where <code>X</code> is a fresh value.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This modeling approach, as with the responder, is similar to the approach taken in cryptographic security models in the game-based setting, where each rule corresponds to a &quot;query&quot;.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Note that we could have re-used <code>~eskI</code> for this purpose, since it will also be unique for each instance.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
    </div>
  </div>
</body>
</html>
