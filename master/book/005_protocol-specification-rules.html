<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamarin Prover Manual</title>
  <link rel="stylesheet" type="text/css" href="book.css">
  <script src="book.js"></script>
  <link rel="stylesheet" href="styles/github.css">
  <!--    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
-->
    <script
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
  </head>

<body class="tamarindoc">
  <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->
  <div id="nav">
    <button id="toggle-nav">
      <span class="sr-only">Toggle navigation</span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
    </button>
  </div>
  <div id='toc' class='mobile-hidden'>
    <ul class='chapter'>
      <!-- <li><a href='000_prelims.html'><b>0. </b>Preliminaries</a></li> -->
      <li><a href='001_introduction.html'><b>1. </b> Introduction</a></li>
      <li><a href='002_installation.html'><b>2. </b> Installation</a></li>
      <li><a href='003_example.html'><b>3. </b> First Example</a></li>
      <li><a href='004_cryptographic-messages.html'><b>4. </b> Cryptographic Messages</a></li>
      <li><a href='005_protocol-specification-rules.html'><b>5. </b> Protocol Specification using Rules</a></li>
      <li><a href='006_protocol-specification-processes.html'><b>6. </b> Protocol Specification using Processes</a></li>
      <li><a href='007_property-specification.html'><b>7. </b> Property Specification</a></li>
      <li><a href='008_accountability.html'><b>8. </b> Accountability</a></li>
      <li><a href='009_precomputation.html'><b>9. </b> Precomputation</a></li>
      <li><a href='010_modeling-issues.html'><b>10. </b> Modeling Issues</a></li>
      <li><a href='011_advanced-features.html'><b>11. </b> Advanced Features</a></li>
      <li><a href='012_case-studies.html'><b>12.</b> Case Studies</a></li>
      <li><a href='013_toolchains.html'><b>13.</b> Toolchains</a></li>
      <li><a href='014_limitations.html'><b>14.</b> Limitations</a></li>
      <li><a href='015_contact-and-further-reading.html'><b>15.</b> Contact Information and Further Reading</a></li>
      <li><a href='016_syntax_description.html'><b>16.</b> Syntax Description</a></li>
    </ul>
  </div>
  <div id='page-wrapper'>
    <div id='page'>
      <p class="halfbreak">
      </p>
      <h1 id="sec:model-specification">Model Specification using
      Rules</h1>
      <p>In this section, we now provide an informal description of the
      underlying model. The full details of this model can be found in
      <span class="citation" data-cites="benediktthesis">(Schmidt
      2012)</span>.</p>
      <p>Tamarin models are specified using three main ingredients:</p>
      <ol type="1">
      <li>Rules</li>
      <li>Facts</li>
      <li>Terms</li>
      </ol>
      <p>We have already seen the definition of terms in the previous
      section. Here we will discuss facts and rules, and illustrate
      their use with respect to the Naxos protocol, displayed below.</p>
      <p><img src="../images/naxos.png" style="width:80.0%"
      alt="The Naxos protocol" /><br />
      </p>
      <!-- **FIX Cas: Picture should be updated and use vector graphics, ideally.**
      -->
      <p>In this protocol, each party <code>x</code> has a long-term
      private key <code>lkx</code> and a corresponding public key
      <code>pkx = 'g'^lkx</code>, where <code>'g'</code> is a generator
      of the Diffie-Hellman group. Because <code>'g'</code> can be
      public, we model it as a public constant. Two different hash
      functions <code>h1</code> and <code>h2</code> are used.</p>
      <p>To start a session, the initiator <code>I</code> first creates
      a fresh nonce <code>eskI</code>, also known as <code>I</code>’s
      ephemeral (private) key. He then concatenates <code>eskI</code>
      with <code>I</code>’s long-term private key <code>lkI</code>,
      hashes the result using the hash function <code>h1</code>, and
      sends <code>'g'^h1(eskI ,lkI)</code> to the responder. The
      responder <code>R</code> stores the received value in a variable
      <code>X</code>, computes a similar value based on his own nonce
      <code>eskR</code> and long-term private key <code>lkR</code>, and
      sends the result to the initiator, who stores the received value
      in the variable <code>Y</code>. Finally, both parties compute a
      session key (<code>kI</code> and <code>kR</code>, respectively)
      whose computation includes their own long-term private keys, such
      that only the intended partner can compute the same key.</p>
      <p>Note that the messages exchanged are not authenticated as the
      recipients cannot verify that the expected long-term key was used
      in the construction of the message. The authentication is implicit
      and only guaranteed through ownership of the correct key. Explicit
      authentication (e.g., the intended partner was recently alive or
      agrees on some values) is commonly achieved in authenticated key
      exchange protocols by adding a key-confirmation step, where the
      parties exchange a MAC of the exchanged messages that is keyed
      with (a variant of) the computed session key.</p>
      <h2 id="sec:rules">Rules</h2>
      <p>We use multiset rewriting to specify the concurrent execution
      of the protocol and the adversary. Multiset rewriting is a
      formalism that is commonly used to model concurrent systems since
      it naturally supports independent transitions.</p>
      <p>A multiset rewriting system defines a transition system, where,
      in our case, the transitions will be labeled. The system’s state
      is a multiset (bag) of facts. We will explain the types of facts
      and their use below.</p>
      <p>A rewrite rule in Tamarin has a name and three parts, each of
      which is a sequence of facts: one for the rule’s left-hand side,
      one labelling the transition (which we call ‘action facts’), and
      one for the rule’s right-hand side. For example:</p>
      <pre><code>rule MyRule1:
  [ ] --[ L(&#39;x&#39;) ]-&gt; [ F(&#39;1&#39;,&#39;x&#39;), F(&#39;2&#39;,&#39;y&#39;) ]

rule MyRule2:
  [ F(u,v) ] --[ M(u,v) ]-&gt; [ H(u), G(&#39;3&#39;,h(v)) ]</code></pre>
      <p>For now, we will ignore the action facts (<code>L(...)</code>
      and <code>M(...)</code>) and return to them when discussing
      properties in the next section. If a rule is not labelled by
      action facts, the arrow notation <code>--[ ]-&gt;</code> can be
      abbreviated to <code>--&gt;</code>.</p>
      <p>The rule names are only used for referencing specific rules.
      They have no specific meaning and can be chosen arbitrarily, as
      long as each rule has a unique name.</p>
      <h3 id="executions">Executions</h3>
      <p>The initial state of the transition system is the empty
      multiset.</p>
      <p>The rules define how the system can make a transition to a new
      state. A rule can be applied to a state if it can be instantiated
      such that its left hand side is contained in the current state. In
      this case, the left-hand side facts are removed from the state,
      and replaced by the instantiated right hand side.</p>
      <p>For example, in the initial state, <code>MyRule1</code> can be
      instantiated repeatedly.</p>
      <p>For any instantiation of <code>MyRule1</code>, this leads to
      follow-up state that contains <code>F('1','x')</code> and
      <code>F('2','y')</code>. <code>MyRule2</code> cannot be applied in
      the initial state since it contains no <code>F</code> facts. In
      the successor state, the rule <code>MyRule2</code> can now be
      applied twice. It can be instantiated either by <code>u</code>
      equal to <code>'1'</code> (with <code>v</code> equal to
      <code>'x'</code>) or to <code>'2'</code> (with <code>v</code>
      equal to <code>'y'</code>). Each of these instantiations leads to
      a new successor state.</p>
      <h3 id="sec:let-rules">Using ‘let’ binding in rules for local
      macros</h3>
      <p>When modeling more complex protocols, a term may occur multiple
      times (possibly as a subterm) within the same rule. To make such
      specifications more readable, Tamarin offers support for
      <code>let ... in</code>, as in the following example:</p>
      <pre><code>rule MyRuleName:
    let foo1 = h(bar)
        foo2 = &lt;&#39;bars&#39;, foo1&gt;
        ...
        var5 = pk(~x)
    in
    [ ... ] --[ ... ]-&gt; [ ... ]</code></pre>
      <p>Such let-binding expressions can be used to specify local term
      macros within the context of a rule. Each macro should occur on a
      separate line and defines a substitution: the left-hand side of
      the <code>=</code> sign must be a variable and the right-hand side
      is an arbitrary term. The rule will be interpreted after
      substituting all variables occurring in the let by their
      right-hand sides. As the above example indicates, macros may use
      the left-hand sides of earlier defined macros.</p>
      <h3 id="sec:macros">Global macros</h3>
      <p>Sometimes we want to use the same let binding(s) in multiples
      rules. In such a case, we can use the <code>macros</code> keyword
      to define global macros, which are applied to all rules. Consider
      the following example:</p>
      <pre><code>macros: macro1(x) = h(x), macro2(x, y) = &lt;x, y&gt;, ..., macro7() = $A</code></pre>
      <p>Here <code>macro1</code> is the name of the first macro, and
      <code>x</code> is its the parameter. The second macro is called
      <code>macro2</code> and has two parameters <code>x</code> and
      <code>y</code>. The last macro <code>macro7</code> has no
      parameters. The the term on the right of the <code>=</code> sign
      is the output of the macro. It can be any term built from the
      functions defined in the equational theory and the parameters of
      the macro.</p>
      <p>To use a macro in a rule, we can use the macro like a function
      inside terms. For example</p>
      <pre><code>[ In(macro1(~ltk)) ] --[ ... ]-&gt; [ Out(macro2(pkA, pkB)) ]</code></pre>
      <p>will become</p>
      <pre><code>[ In(h(~ltk)) ] --[ ... ]-&gt; [ Out(&lt;pkA, pkB&gt;) ]</code></pre>
      <p>after the above macros have been applied.</p>
      <p>A macro can call a second macro, if the second one was defined
      before. For example, one can define the following two macros:</p>
      <pre><code>macros: innerMacro(x, y) = &lt;x, y&gt;, hashMacro(x, y) = h(innerMacro(x, y))</code></pre>
      <p>However, the following snippet would result in an error</p>
      <pre><code>macros: hashMacro(x, y) = h(innerMacro(x, y)), innerMacro(x, y) = &lt;x, y&gt;</code></pre>
      <p>as <code>innerMacro</code> is not yet defined when
      <code>hashMacro</code> is defined.</p>
      <p>Macros only apply to rules, and are shown in interactive mode
      together with the protocol rules. When exporting a theory, Tamarin
      will export the original rules (before the macros were applied)
      and the macros.</p>
      <h2 id="facts">Facts</h2>
      <p>Facts are of the form <code>F(t1,...,tn)</code> for a fact
      symbol <code>F</code> and terms <code>ti</code>. They have a fixed
      arity (in this case <code>n</code>). Note that if a Tamarin model
      uses the same fact with two different arities, Tamarin will report
      an error.</p>
      <p>There are three types of special facts built in to Tamarin.
      These are used to model interaction with the untrusted network and
      to model the generation of unique fresh (random) values.</p>
      <dl>
      <dt><code>In</code></dt>
      <dd>
      <p>This fact is used to model a party receiving a message from the
      untrusted network that is controlled by a Dolev-Yao adversary, and
      can only occur on the left-hand side of a rewrite rule.</p>
      </dd>
      <dt><code>Out</code></dt>
      <dd>
      <p>This fact is used to model a party sending a message to the
      untrusted network that is controlled by a Dolev-Yao adversary, and
      can only occur on the right-hand side of a rewrite rule.</p>
      </dd>
      <dt><code>Fr</code></dt>
      <dd>
      <p>This fact must be used when generating fresh (random) values,
      and can only occur on the left-hand side of a rewrite rule, where
      its argument is the fresh term. Tamarin’s underlying execution
      model has a built-in rule for generating instances of
      <code>Fr(x)</code> facts, and also ensures that each instance
      produces a term (instantiating <code>x</code>) that is different
      from all others.</p>
      </dd>
      </dl>
      <p>For the above three facts, Tamarin has built-in rules. In
      particular, there is a fresh rule that produces unique
      <code>Fr(...)</code> facts, and there is a set of rules for
      adversary knowledge derivation, which consume
      <code>Out(...)</code> facts and produce <code>In(...)</code>
      facts.</p>
      <h3 id="linear-versus-persistent-facts">Linear versus persistent
      facts</h3>
      <p>The facts mentioned above are called ‘linear facts’. They are
      not only produced by rules, they also can be consumed by rules.
      Hence they might appear in one state but not in the next.</p>
      <p>In contrast, some facts in our models will never be removed
      from the state once they are introduced. Modeling this using
      linear facts would require that every rule that has such a fact in
      the left-hand-side, also has an exact copy of this fact in the
      right-hand side. While there is no fundamental problem with this
      modeling in theory, it is inconvenient for the user and it also
      might lead Tamarin to explore rule instantiations that are
      irrelevant for tracing such facts in practice, which may even lead
      to non-termination.</p>
      <p>For the above two reasons, we now introduce ‘persistent facts’,
      which are never removed from the state. We denote these facts by
      prefixing them with a bang (<code>!</code>).</p>
      <p>Facts always start with an upper-case letter and need not be
      declared explicitly. If their name is prefixed with an exclamation
      mark <code>!</code>, then they are persistent. Otherwise, they are
      linear. Note that every fact name must be used consistently; i.e.,
      it must always be used with the same arity, case, persistence, and
      multiplicity. Otherwise, Tamarin complains that the theory is not
      well-formed.</p>
      <p>Comparing linear and persistent fact behaviour we note that if
      there is a persistent fact in some rule’s premise, then Tamarin
      will consider all rules that produce this persistent fact in their
      conclusion as the source. Usually though, there are few such rules
      (most often just a single one), which simplifies the reasoning.
      For linear facts, particularly those that are used in many rules
      (and kept static), obviously there are many rules with the fact in
      their conclusion (all of them!). Thus, when looking for a source
      in any premise, all such rules need to be considered, which is
      clearly less efficient and non-termination-prone as mentioned
      above. Hence, when trying to model facts that are never consumed,
      the use of persistent facts is preferred.</p>
      <h3 id="sec:embeddedrestrictions">Embedded restrictions</h3>
      <p>A frequently used trick when modelling protocols is to enforce
      a restriction on the trace once a certain rule is invoked, for
      instance if the step represented by the rule requires another step
      at some later point in time, e.g., to model a reliable channel. <a
      href="007_property-specification.html#sec:restrictions">We explain
      what restriction are later</a>, but roughly speaking, they specify
      constraints that a protocol execution should uphold.</p>
      <p>This can be done by hand, namely by specifying a restriction
      that refers to an <code>action fact</code> unique to this rule, or
      by using embedded restrictions like this:</p>
      <pre><code>rule B:
    [In(x), In(y)] --[ _restrict( formula )]-&gt; []</code></pre>
      <p>where <code>formula</code> is a restriction. Note that embedded
      restrictions currently are only available in trace mode.</p>
      <h2 id="modeling-protocols">Modeling protocols</h2>
      <p>There are several ways in which the execution of security
      protocols can be defined, e.g., as in <span class="citation"
      data-cites="opsem2012">(Cremers and Mauw 2012)</span>. In Tamarin,
      there is no pre-defined protocol concept and the user is free to
      model them as she or he chooses. Below we give an example of how
      protocols can be modeled and discuss alternatives afterwards.</p>
      <h3 id="public-key-infrastructure">Public-key infrastructure</h3>
      <p>In the Tamarin model, there is no pre-defined notion of public
      key infrastructure (PKI). A pre-distributed PKI with asymmetric
      keys for each party can be modeled by a single rule that generates
      a key for a party. The party’s identity and public/private keys
      are then stored as facts in the state, enabling protocol rules to
      retrieve them. For the public key, we commonly use the
      <code>Pk</code> fact, and for the corresponding long-term private
      key we use the <code>Ltk</code> fact. Since these facts will only
      be used by other rules to retrieve the keys, but never updated, we
      model them as persistent facts. We use the abstract function
      <code>pk(x)</code> to denote the public key corresponding to the
      private key <code>x</code>, leading to the following rule. Note
      that we also directly give all public keys to the attacker,
      modeled by the <code>Out</code> on the right-hand side.</p>
      <pre><code>rule Generate_key_pair:
  [ Fr(~x) ]
  --&gt;
  [ !Pk($A,pk(~x))
  , Out(pk(~x))
  , !Ltk($A,~x)
  ]</code></pre>
      <p>Some protocols, such as Naxos, rely on the algebraic properties
      of the key pairs. In many DH-based protocols, the public key is
      <span class="math inline">\(g^x\)</span> for the private key <span
      class="math inline">\(x\)</span>, which enables exploiting the
      commutativity of the exponents to establish keys. In this case, we
      specify the following rule instead.</p>
      <pre><code>rule Generate_DH_key_pair:
  [ Fr(~x) ]
  --&gt;
  [ !Pk($A,&#39;g&#39;^~x)
  , Out(&#39;g&#39;^~x)
  , !Ltk($A,~x)
  ]</code></pre>
      <h3 id="modeling-a-protocol-step">Modeling a protocol step</h3>
      <p>Protocols describe the behavior of agents in the system. Agents
      can perform protocol steps, such as receiving a message and
      responding by sending a message, or starting a session.</p>
      <h3 id="modeling-the-naxos-responder-role">Modeling the Naxos
      responder role</h3>
      <p>We first model the responder role, which is simpler than the
      initiator role since it can be done in one rule.</p>
      <p>The protocol uses a Diffie-Hellman exponentiation, and two hash
      functions <code>h1</code> and <code>h2</code>, which we must
      declare. We can model this using:</p>
      <pre><code>builtins: diffie-hellman</code></pre>
      <p>and</p>
      <pre><code>functions: h1/1
functions: h2/1</code></pre>
      <p>Without any further equations, a function declared in this
      fashion will behave as a one-way function.</p>
      <p>Each time a responder thread of an agent <code>$R</code>
      receives a message, it will generate a fresh value
      <code>~eskR</code>, send a response message, and compute a key
      <code>kR</code>. We can model receiving a message by specifying an
      <code>In</code> fact on the left-hand side of a rule. To model the
      generation of a fresh value, we require it to be generated by the
      built-in fresh rule.</p>
      <p>Finally, the rule depends on the actor’s long-term private key,
      which we can obtain from the persistent fact generated by the
      <code>Generate_DH_key_pair</code> rule presented previously.</p>
      <p>The response message is an exponentiation of <code>g</code> to
      the power of a computed hash function. Since the hash function is
      unary (arity one), if we want to invoke it on the concatenation of
      two messages, we model them as a pair <code>&lt;x,y&gt;</code>
      which will be used as the single argument of <code>h1</code>.</p>
      <p>Thus, an initial formalization of this rule might be as
      follows:</p>
      <pre><code>    rule NaxosR_attempt1:
            [
              In(X),
              Fr(~eskR),
              !Ltk($R, lkR)
            ]
            --&gt;
            [
              Out( &#39;g&#39;^h1(&lt; ~eskR, lkR &gt;) )
            ]</code></pre>
      <p>However, the responder also computes a session key
      <code>kR</code>. Since the session key does not affect the sent or
      received messages, we can omit it from the left-hand side and the
      right-hand side of the rule. However, later we will want to make a
      statement about the session key in the security property. We
      therefore add the computed key to the actions:</p>
      <pre><code>    rule NaxosR_attempt2:
            [
              In(X),
              Fr(~eskR),
              !Ltk($R, lkR)
            ]
            --[ SessionKey($R, kR ) ]-&gt;
            [
              Out( &#39;g&#39;^h1(&lt; ~eskR, lkR &gt;) )
            ]</code></pre>
      <p>The computation of <code>kR</code> is not yet specified in the
      above. We could replace <code>kR</code> in the above rule by its
      full unfolding, but this would decrease readability. Instead, we
      use let binding to avoid duplication and reduce possible
      mismatches. Additionally, for the key computation we need the
      public key of the communication partner <code>$I</code>, which we
      bind to a unique thread identifier <code>~tid</code>; we use the
      resulting action fact to specify security properties, as we will
      see in the next section. This leads to:</p>
      <pre><code>    rule NaxosR_attempt3:
      let
          exR = h1(&lt; ~eskR, lkR &gt;)
          hkr = &#39;g&#39;^exR
          kR  = h2(&lt; pkI^exR, X^lkR, X^exR, $I, $R &gt;)
      in
       [
           In(X),
           Fr( ~eskR ),
           Fr( ~tid ),
           !Ltk($R, lkR),
           !Pk($I, pkI)
       ]
       --[ SessionKey( ~tid, $R, $I, kR ) ]-&gt;
       [
           Out( hkr )
       ]</code></pre>
      <p>The above rule models the responder role accurately, and
      computes the appropriate key.</p>
      <p>We note one further optimization that helps Tamarin’s backwards
      search. In <code>NaxosR_attempt3</code>, the rule specifies that
      <code>lkR</code> might be instantiated with any term, hence also
      non-fresh terms. However, since the key generation rule is the
      only rule that produces <code>Ltk</code> facts, and it will always
      use a fresh value for the key, it is clear that in any reachable
      state of the system, <code>lkR</code> can only become instantiated
      by fresh values. We can therefore mark <code>lkR</code> as being
      of sort fresh, therefore replacing it by <code>~lkR</code>.<a
      href="#fn1" class="footnote-ref" id="fnref1"
      role="doc-noteref"><sup>1</sup></a></p>
      <pre class="tamarin"><code>rule NaxosR:
  let 
      exR = h1(&lt; ~eskR, ~lkR &gt;)
      hkr = &#39;g&#39;^exR
      kR  = h2(&lt; pkI^exR, X^~lkR, X^exR, $I, $R &gt;)
  in
   [
       In(X),
       Fr( ~eskR ),
       Fr( ~tid ),
       !Ltk($R, ~lkR),
       !Pk($I, pkI)
   ]
   --[ SessionKey( ~tid, $R, $I, kR ) ]-&gt;
   [
       Out( hkr )
   ]</code></pre>
      <p>The above rule suffices to model basic security properties, as
      we will see later.</p>
      <h3 id="modeling-the-naxos-initiator-role">Modeling the Naxos
      initiator role</h3>
      <p>The initiator role of the Naxos protocol consists of sending a
      message and waiting for the response. While the initiator is
      waiting for a response, other agents might also perform steps. We
      therefore model the initiator using two rules.<a href="#fn2"
      class="footnote-ref" id="fnref2"
      role="doc-noteref"><sup>2</sup></a></p>
      <p>The first rule models an agent starting the initiator role,
      generating a fresh value, and sending the appropriate message. As
      before, we use let binding to simplify the presentation and use
      <code>~lkI</code> instead of <code>lkI</code> since we know that
      <code>!Ltk</code> facts are only produced with a fresh value as
      the second argument.</p>
      <pre><code>    rule NaxosI_1_attempt1:
      let exI = h1(&lt;~eskI, ~lkI &gt;)
          hkI = &#39;g&#39;^exI
      in
       [   Fr( ~eskI ),
           !Ltk( $I, ~lkI ) ]
       --&gt;
       [   Out( hkI ) ]</code></pre>
      <h4 id="using-state-facts-to-model-progress">Using state facts to
      model progress</h4>
      <p>After triggering the previous rule, an initiator will wait for
      the response message. We still need to model the second part, in
      which the response is received and the key is computed. To model
      the second part of the initiator rule, we must be able to specify
      that it was preceded by the first part and with specific
      parameters. Intuitively, we must store in the state of the
      transition system that there is an initiator thread that has
      performed the first send with specific parameters, so it can
      continue where it left off.</p>
      <p>To model this, we introduce a new fact, which we often refer to
      as a <em>state fact</em>: a fact that indicates that a certain
      process or thread is at a specific point in its execution,
      effectively operating both as a program counter and as a container
      for the contents of the memory of the process or thread. Since
      there can be any number of initiators in parallel, we need to
      provide a unique handle for each of their state facts.</p>
      <p>Below we provide an updated version of the initiator’s first
      rule that produces a state fact <code>Init_1</code> and introduces
      a unique thread identifier <code>~tid</code> for each instance of
      the rule.</p>
      <pre class="tamarin"><code>rule NaxosI_1:
  let exI = h1(&lt;~eskI, ~lkI &gt;)
      hkI = &#39;g&#39;^exI
  in
   [   Fr( ~eskI ),
       Fr( ~tid ),
       !Ltk( $I, ~lkI ) ]
   --&gt;
   [   Init_1( ~tid, $I, $R, ~lkI, ~eskI ),
       Out( hkI ) ]</code></pre>
      <p>Note that the state fact has several parameters: the unique
      thread identifier <code>~tid</code><a href="#fn3"
      class="footnote-ref" id="fnref3"
      role="doc-noteref"><sup>3</sup></a>, the agent identities
      <code>$I</code> and <code>$R</code>, and the actor’s long-term
      private key <code>~lkI</code>, and the private exponent. This now
      enables us to specify the second initiator rule.</p>
      <pre class="tamarin"><code>rule NaxosI_2:
  let
      exI = h1(&lt; ~eskI, ~lkI &gt;)
      kI  = h2(&lt; Y^~lkI, pkR^exI, Y^exI, $I, $R &gt;)
  in
   [   Init_1( ~tid, $I, $R, ~lkI , ~eskI),
       !Pk( $R, pkR ),
       In( Y ) ]
   --[ SessionKey( ~tid, $I, $R, kI ) ]-&gt;
  []</code></pre>
      <p>This second rule requires receiving a message <code>Y</code>
      from the network but also that an initiator fact was previously
      generated. This rule then consumes this fact, and since there are
      no further steps in the protocol, does not need to output a
      similar fact. As the <code>Init_1</code> fact is instantiated with
      the same parameters, the second step will use the same agent
      identities and the exponent <code>exI</code> computed in the first
      step.</p>
      <p>Thus, the complete example becomes:</p>
      <pre class="tamarin"><code>theory Naxos
begin

builtins: diffie-hellman

functions: h1/1
functions: h2/1

rule Generate_DH_key_pair:
  [ Fr(~x) ] 
  --&gt; 
  [ !Pk($A,&#39;g&#39;^~x)
  , Out(&#39;g&#39;^~x)
  , !Ltk($A,~x)
  ]

rule NaxosR:
  let 
      exR = h1(&lt; ~eskR, ~lkR &gt;)
      hkr = &#39;g&#39;^exR
      kR  = h2(&lt; pkI^exR, X^~lkR, X^exR, $I, $R &gt;)
  in
   [
       In(X),
       Fr( ~eskR ),
       Fr( ~tid ),
       !Ltk($R, ~lkR),
       !Pk($I, pkI)
   ]
   --[ SessionKey( ~tid, $R, $I, kR ) ]-&gt;
   [
       Out( hkr )
   ]

rule NaxosI_1:
  let exI = h1(&lt;~eskI, ~lkI &gt;)
      hkI = &#39;g&#39;^exI
  in
   [   Fr( ~eskI ),
       Fr( ~tid ),
       !Ltk( $I, ~lkI ) ]
   --&gt;
   [   Init_1( ~tid, $I, $R, ~lkI, ~eskI ),
       Out( hkI ) ]

rule NaxosI_2:
  let
      exI = h1(&lt; ~eskI, ~lkI &gt;)
      kI  = h2(&lt; Y^~lkI, pkR^exI, Y^exI, $I, $R &gt;)
  in
   [   Init_1( ~tid, $I, $R, ~lkI , ~eskI),
       !Pk( $R, pkR ),
       In( Y ) ]
   --[ SessionKey( ~tid, $I, $R, kI ) ]-&gt;
  []

end</code></pre>
      <p>Note that the protocol description only specifies a model, but
      not which properties it might satisfy. We discuss these in the
      next section.</p>
      <!--
      **FIX Cas: need to do either pattern matching or explicit construct/deconstruct;
      not a big deal for naxos, but should pop up somewhere**
      Alternative modeling approaches
      -------------------------------

      **FIX Cas: splitting send/receive, etc.**

      **FIX Cas: pattern matching vs deconstructors**





      TODO:
        * Example use-cases for variable annotations ($ ~), and any caveats that
          might come with them (like if incorrect ~ use can make things unsound)

        * An explanation/examples of the difference between K, KU, and KD, and when
          you would use each. (This should go in the next section)
      -->
      <div id="refs" class="references csl-bib-body hanging-indent"
      role="doc-bibliography">
      <div id="ref-opsem2012" class="csl-entry" role="doc-biblioentry">
      Cremers, Cas, and Sjouke Mauw. 2012. <em><span
      class="nocase">Operational Semantics and Verification of Security
      Protocols</span></em>. Springer-Verlag Berlin Heidelberg. <a
      href="https://doi.org/10.1007/978-3-540-78636-8">https://doi.org/10.1007/978-3-540-78636-8</a>.
      </div>
      <div id="ref-benediktthesis" class="csl-entry"
      role="doc-biblioentry">
      Schmidt, Benedikt. 2012. <span>“Formal Analysis of Key Exchange
      Protocols and Physical Protocols.”</span> PhD thesis, ETH Zurich.
      <a
      href="http://dx.doi.org/10.3929/ethz-a-009898924">http://dx.doi.org/10.3929/ethz-a-009898924</a>.
      </div>
      </div>
      <section class="footnotes footnotes-end-of-document"
      role="doc-endnotes">
      <hr />
      <ol>
      <li id="fn1" role="doc-endnote"><p>Note that in contrast,
      replacing <code>X</code> by <code>~X</code> would change the
      interpretation of the model, effectively restricting the
      instantiations of the rule to those where <code>X</code> is a
      fresh value.<a href="#fnref1" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn2" role="doc-endnote"><p>This modeling approach, as with
      the responder, is similar to the approach taken in cryptographic
      security models in the game-based setting, where each rule
      corresponds to a “query”.<a href="#fnref2" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn3" role="doc-endnote"><p>Note that we could have re-used
      <code>~eskI</code> for this purpose, since it will also be unique
      for each instance.<a href="#fnref3" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      </ol>
      </section>
    </div>
  </div>
</body>

</html>
